---
title: 'OpenTelemetry tutorial: Instrument a sample Java app'
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: You can set up OpenTelemetry to monitor a simple Java app.
---

import opentelemetrySpringBootASCIIDisplay from 'images/opentelemetry_screenshot-crop_Spring-Boot-ASCII-display.png'

import opentelemetryMainDistributedTracingPage from 'images/opentelemetry_screenshot-crop_main-distributed-tracing-page.png'

import opentelemetryDistributedTracingError from 'images/opentelemetry_screenshot-crop_distributed-tracing-error.png'

import opentelemetryInProcessSpans from 'images/opentelemetry_screenshot-crop_in-process-spans.png'

import opentelemetryExceptiononSpanEvent from 'images/opentelemetry_screenshot-crop_exception-on-span-event.png'

import opentelemetryAttributesTab from 'images/opentelemetry_screenshot-crop_attributes-tab.png'


Try out this Java tutorial to see what the New Relic platform can do with your OTLP data. You can quickly learn how to configure your OpenTelemetry SDK to optimize your observability experience in New Relic. You'll do all this using a demo Spring application that generates the nth number in the Fibonacci sequence.

You'll find three tracks below to help you get acquainted with New Relic and OpenTelmentry. Try out the tracks that are interesting to you:

* [Run our pre-instrumented program:](#pre-instrum) This is the fastest way to send some demo data to New Relic and see how it is displayed in the UI. This demo has instrumentation and configurations that follow our [best practices](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-overview/) to generate and export metrics, logs, and traces.
* **Use the OpenTelemetry Java agent:** This is also a pretty quick way to get some data into New Relic, but in this track, you'll use the OpenTelemetry Java agent that automatically monitors Java applications. Some users may start with this approach and then add manual instrumentation to get additional, custom details from their telemetry.
* **Instrument the demo app yourself:** In this track, you'll roll up your sleeves and tinker with the engine of the car. You'll manually insert instrumentation that enables you to send data from the demo app to New Relic.

## Requirements [#requirements]

Before you get started, make sure you have the following:

* A New Relic account: Sign up for a [free account](https://newrelic.com/signup) if you don't already have one.
* Java 17 or higher: If you don't already have this, see [these download options](https://www.java.com/en/download/manual.jsp).
* IntelliJ IDEA: We recommend that you use the IntelliJ IDE while completing this guide. If you don't have IntelliJ, you can download the [free community version](https://www.jetbrains.com/help/idea/installation-guide.html#requirements).

## Run our pre-instrumented program [#pre-instrum]

This is a great option if you want to quickly see how a program can send data to New Relic.

1. Clone the demo app and navigate to the `java` directory:

    ```
    git clone Head to your [New Relic account](https://one.newrelic.com) and look for an entity called “getting-started-java” in your `Services - OpenTelemetry` list. Explore the UI. 
To shut down the application, run control + c in both terminal tabs.

    cd Instrumented/java
    ```
2. In your terminal, set these two environment variables to send data to your New Relic account:

    ```
    export newrelicLicenseKey=<your_license_key>
    export newrelicOtlpEndpoint=https://otlp.nr-data.net:4317
    ```
    * Make sure to use your [ingest license key](https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/#license-key):
    * By default, the OTLP exporter is pointed to one of [New Relic's OTLP endpoints](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-setup#review-settings). You can override it by setting a different value, for instance, if your account is based in the EU:
        * For US-based accounts: https://otlp.nr-data.net:4317
        * For EU-based accounts: https://otlp.eu01.nr-data.net:4317  

3. In the `Instrumented/java` directory, run the application:

    ```
    ./gradlew bootRun
    ```
4. Open a new terminal and exercise the application from the `Instrumented/java directory` by running this command:

    ```
    ./load-generator.sh
    ```
5. Go to your [New Relic account](https://one.newrelic.com/all-capabilities) and look for an entity called “getting-started-java” in your `Services - OpenTelemetry` list. Explore the UI. 
To shut down the application, run control + c in both terminal tabs.

Each trace is made up of spans, which represent a logical unit of work or an operation within a particular request. You will learn how to create and end a span, set an attribute on a span, and record an exception, which is captured on the span as a span event.

<Callout variant="tip">
  If you have any questions about the status of traces in the OpenTelemetry project, see the [signal statuses](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases).
</Callout>

During this tutorial for generating and exporting traces, you'll open up the demo app and add dependencies, resources, a trace provider, exporter, and some instrumentation. Then, you'll run the app and check out the traces in the New Relic UI.




## A. Download the demo application [#download]

Start by cloning the demo application, which generates the nth number in the Fibonacci sequence:

```
git clone git@github.com:reese-lee/getting-started-guides.git
```
## B. Add OpenTelemetry Dependencies [#dependencies]

To add dependencies:

1. Go to the application's `java` directory.

    ```
    cd Uninstrumented/java
    ```
2. Open `build.gradle` in your preferred text editor.
3. Add the following in the `dependencies` block of the `build.gradle` file:
    ```
    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter-web'

        <var>// OpenTelemetry core</var>
        <var>implementation platform('io.opentelemetry:opentelemetry-bom:1.20.1')</var>
        <var>implementation platform('io.opentelemetry:opentelemetry-bom-alpha:1.20.1-alpha')</var>
        <var>implementation 'io.opentelemetry:opentelemetry-api'</var>
        <var>implementation 'io.opentelemetry:opentelemetry-sdk'</var>
        <var> implementation 'io.opentelemetry:opentelemetry-exporter-otlp'</var>

        <var>// OpenTelemetry instrumentation</var>
        <var>implementation platform('io.opentelemetry.instrumentation:opentelemetry-instrumentation-bom-alpha:1.20.2-alpha')</var>
        <var>implementation 'io.opentelemetry.instrumentation:opentelemetry-spring-webmvc-5.3'</var>
    }
    ```

Notes:

* The `bom` (bill of materials) dependencies are used to synchronize versions of dependencies for a particular ecosystem. Since OpenTelemetry publishes a lot of Java components, these help ensure that all the versions are synchronized, whether you use just a few or a lot of them.
* The remaining dependencies provide access to the SDK, API, OTLP exporter, and instrumentation libraries.
* If you have imports optimized in your Intellij IDE, then Intellij will take care of imports for you once you've added the dependencies in your `build.gradle` file and refreshed it.


## C. Configure a resource [#provide-resource]

A resource in OpenTelemetry represents information about an entity generating telemetry data. You'll learn how to associate all telemetry data you send to New Relic with a resource so it can be linked with the appropriate entity in New Relic.

<Callout variant="tip">
  For this Java tutorial, you have the option of using the [SDK autoconfigure extension module](https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions/autoconfigure) to configure the SDK. See [SDK auto config](#SDK-auto-config) for how to set this up. This extension only impacts the SDK configuration&mdash;you will still need to instrument the application following the instrumentation steps in this guide.
</Callout>

1. Go to the app's source code directory:
    ```
    cd src/main/java/com/example/demo
    ```
2. Open `Application.java`.
3. Configure an instance of the OpenTelemetry SDK as early as possible, as well as make OpenTelemetry available via dependency injection by adding this:
    ```
    @SpringBootApplication
    public class Application {

      <var>private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();</var>

      public static void main(String[] args) {
        <var>// Configure OpenTelemetry as early as possible</var>
        <var>var openTelemetrySdk = openTelemetrySdk();</var>
        <var>Application.openTelemetry = openTelemetrySdk;</var>

        SpringApplication.run(Application.class, args);
      }

      <var>@Bean</var>
      <var>public OpenTelemetry openTelemetry() {</var>
        <var>return openTelemetry;</var>
      <var>}</var>

      <var>private static OpenTelemetrySdk openTelemetrySdk() {</var>

        <var>// Configure resource</var>
        <var>var resource =</var>
                <var>Resource.getDefault().toBuilder()</var>
                        <var>.put(ResourceAttributes.SERVICE_NAME, "getting-started-java")</var>
                        <var>.put(ResourceAttributes.SERVICE_INSTANCE_ID, UUID.randomUUID().toString())</var>
                        <var>.build();</var>

        <var>// Bring it all together</var>
        <var>return OpenTelemetrySdk.builder()</var>
                <var>.setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))</var>
                <var>.build();</var>

      <var>}</var>
    }

    ```

Notes:

* `SERVICE_NAME` defines your app name and will be how you identify your service in New Relic. This value is also how you associate all the telemetry data generated by this app with an entity in New Relic, and allows you to scope your queries to a specific entity.
* `SERVICE_INSTANCE_ID` is required to light up certain New Relic features; it will allow you to differentiate between hosts.

## D. Configure a tracer provider [#trace-provider]

The tracer provider will create a [Tracer](https://opentelemetry.io/docs/concepts/signals/traces/#tracer), which creates spans that contain more information about a given operation, such as a service request. You will instantiate the tracer later when you complete the [instrumentation steps](#initial-instrum).

Continue in `Application.java` and add the following:

```
@SpringBootApplication
public class Application {

  private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

  public static void main(String[] args) {
    // Configure OpenTelemetry as early as possible
    var openTelemetrySdk = openTelemetrySdk();
    Application.openTelemetry = openTelemetrySdk;

    SpringApplication.run(Application.class, args);
  }

  @Bean
  public OpenTelemetry openTelemetry() {
    return openTelemetry;
  }

  private static OpenTelemetrySdk openTelemetrySdk() {

    // Configure resource
    var resource =
            Resource.getDefault().toBuilder()
                    .put(ResourceAttributes.SERVICE_NAME, "getting-started-java")
                    .put(ResourceAttributes.SERVICE_INSTANCE_ID, UUID.randomUUID().toString())
                    .build();
    <var>// Configure tracer provider</var>
    <var>var sdkTracerProviderBuilder =</var>
            <var>SdkTracerProvider.builder()</var>
                    <var>.setResource(resource)</var>
                    <var>// New Relic's max attribute length is 4095 characters</var>
                    <var>.setSpanLimits(</var>
                            <var>SpanLimits.getDefault().toBuilder().setMaxAttributeValueLength(4095).build());</var>

    // Bring it all together
    return OpenTelemetrySdk.builder()
            .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
            <var>.setTracerProvider(sdkTracerProviderBuilder.build())</var>
            .build();

  }
}

```

Notes:

Setting a limit on the maximum attribute value length will prevent span data from getting dropped if it exceeds [New Relic's limit](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-attributes/).

## E. Configure an OTLP span exporter

This is the component that sends spans from your application to New Relic.

You'll first instantiate the two environment variables you are going to use for your OTLP exporter, and then you'll add the span exporter.

By adding the two environment variables here, your license key is not hardcoded and makes it simpler to update your OTLP endpoint. Optionally, you can choose to not export `newrelicOtlpEndpoint`, since you are configuring the New Relic OTLP endpoint as the default below. If you are based in the EU, set it to `https://otlp.eu01.nr-data.net:4317`.

1. Continue in `Application.java` and add the environment variables:

    ```
    @SpringBootApplication
    public class Application {

      private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

      public static void main(String[] args) {
        // Configure OpenTelemetry as early as possible
        var openTelemetrySdk = openTelemetrySdk();
        Application.openTelemetry = openTelemetrySdk;

        SpringApplication.run(Application.class, args);
      }

      @Bean
      public OpenTelemetry openTelemetry() {
        return openTelemetry;
      }

      private static OpenTelemetrySdk openTelemetrySdk() {
        <var>// Environment variables for your OTLP exporters</var>
        <var>var newrelicLicenseKey = getEnvOrDefault("newrelicLicenseKey", Function.identity(), "");</var>
        <var>var newrelicOtlpEndpoint = getEnvOrDefault("newrelicOtlpEndpoint", Function.identity(), "https://otlp.nr-data.net:4317");</var>

        // Configure resource
        var resource =
                Resource.getDefault().toBuilder()
                        .put(ResourceAttributes.SERVICE_NAME, "getting-started-java")
                        .put(ResourceAttributes.SERVICE_INSTANCE_ID, UUID.randomUUID().toString())
                        .build();
        // Configure tracer provider
        var sdkTracerProviderBuilder =
                SdkTracerProvider.builder()
                        .setResource(resource)
                        // New Relic's max attribute length is 4095 characters
                        .setSpanLimits(
                                SpanLimits.getDefault().toBuilder().setMaxAttributeValueLength(4095).build());

        // Bring it all together
        return OpenTelemetrySdk.builder()
                .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
                .setTracerProvider(sdkTracerProviderBuilder.build())
                .build();

      }

      <var>private static <T> T getEnvOrDefault(</var>
              <var>String key, Function<String, T> transformer, T defaultValue) {</var>
        <var>return Optional.ofNullable(System.getenv(key))</var>
                <var>.filter(s -> !s.isBlank())</var>
                <var>.or(() -> Optional.ofNullable(System.getProperty(key)))</var>
                <var>.filter(s -> !s.isBlank())</var>
                <var>.map(transformer)</var>
                <var>.orElse(defaultValue);</var>
      }
    }
    ```
2. Configure your OTLP span exporter directly under your tracer provider:

```
    @SpringBootApplication
    public class Application {

      private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

      public static void main(String[] args) {
        // Configure OpenTelemetry as early as possible
        var openTelemetrySdk = openTelemetrySdk();
        Application.openTelemetry = openTelemetrySdk;

        SpringApplication.run(Application.class, args);
      }

      @Bean
      public OpenTelemetry openTelemetry() {
        return openTelemetry;
      }

      private static OpenTelemetrySdk openTelemetrySdk() {
        // Environment variables for your OTLP exporters
        var newrelicLicenseKey = getEnvOrDefault("newrelicLicenseKey", Function.identity(), "");
        var newrelicOtlpEndpoint = getEnvOrDefault("newrelicOtlpEndpoint", Function.identity(), "https://otlp.nr-data.net:4317");

        // Configure resource
        var resource =
                Resource.getDefault().toBuilder()
                        .put(ResourceAttributes.SERVICE_NAME, "getting-started-java")
                        .put(ResourceAttributes.SERVICE_INSTANCE_ID, UUID.randomUUID().toString())
                        .build();
        // Configure tracer provider
        var sdkTracerProviderBuilder =
                SdkTracerProvider.builder()
                        .setResource(resource)
                        // New Relic's max attribute length is 4095 characters
                        .setSpanLimits(
                                SpanLimits.getDefault().toBuilder().setMaxAttributeValueLength(4095).build());

        // Add otlp span exporter
        <var>var spanExporterBuilder =</var>
                <var>OtlpGrpcSpanExporter.builder()</var>
                        <var>.setEndpoint(newrelicOtlpEndpoint)</var>
                        <var>.setCompression("gzip")</var>
                        <var>.addHeader("api-key", newrelicLicenseKey);</var>
        <var>sdkTracerProviderBuilder.addSpanProcessor(</var>
                <var>BatchSpanProcessor.builder(spanExporterBuilder.build()).build());</var>


        // Bring it all together
        return OpenTelemetrySdk.builder()
                .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
                .setTracerProvider(sdkTracerProviderBuilder.build())
                .build();

      }

      private static <T> T getEnvOrDefault(
              String key, Function<String, T> transformer, T defaultValue) {
        return Optional.ofNullable(System.getenv(key))
                .filter(s -> !s.isBlank())
                .or(() -> Optional.ofNullable(System.getProperty(key)))
                .filter(s -> !s.isBlank())
                .map(transformer)
                .orElse(defaultValue);
      }
    }
```


Notes:

* You will set both of the following environment variables when you complete the [steps](#export-for-otlp) in the next section:
    * `newrelicOtlpEndpoint` is how you configure where the generated data will be exported to.
    * `newrelicLicenseKey` is how you configure which New Relic account you want your data exported to.
* Setting `gzip` compression allows you to maximize the amount of data you can send per request; New Relic's maximum allowed payload size is 1MB (10^6 bytes).

## F. Export the environment variables for your OTLP exporter [#export-for-otlp]

Now, export the two environment variables you configured in your OTLP exporter.

Before you create the environment variables, keep the following in mind:

* Make sure to use your [ingest license key](https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/#license-key):
* By default, the OTLP exporter is pointed to one of [New Relic's OTLP endpoints](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-setup#review-settings). You can override it by setting a different value, for instance, if your account is based in the EU:
    * For US-based accounts: https://otlp.nr-data.net:4317
    * For EU-based accounts: https://otlp.eu01.nr-data.net:4317

Run the commands below in your terminal or command prompt:

```
export newrelicLicenseKey=INSERT_YOUR_LICENSE_KEY_HERE
export newrelicOtlpEndpoint=https://otlp.nr-data.net:4317
```

## G. Instrument the code: Provide automatic base instrumentation [#initial-instrum]

At this point, you have successfully configured your OpenTelemetry resource for tracing. Now you can instrument the application code.

Here are the steps:

1. In  `Application.java`, add the following code to provide automatic base instrumentation for Spring web applications:

    ```
    @SpringBootApplication
    public class Application {

      private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

      public static void main(String[] args) {
        // Configure OpenTelemetry as early as possible
        var openTelemetrySdk = openTelemetrySdk();
        Application.openTelemetry = openTelemetrySdk;

        SpringApplication.run(Application.class, args);
      }

      @Bean
      public OpenTelemetry openTelemetry() {
        return openTelemetry;
      }

      <var>// Add Spring WebMVC instrumentation by registering a tracing filter</var>
      <var>@Bean</var>
      <var>public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {</var>
        <var>return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();</var>
      <var>}</var>

      private static OpenTelemetrySdk openTelemetrySdk() {
    . . .
      }

      private static <T> T getEnvOrDefault(
    . . .
      }
    }
    ```

2. Complete instrumentation by going to `Controller.java` and adding the following code:

    ```
    @RestController
    public class Controller {

      <var>// Attribute constants
      <var>private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
      <var>private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");

      <var>private final Tracer tracer;

     <var> @Autowired
      <var>Controller(OpenTelemetry openTelemetry) {
        <var>// Initialize tracer
        <var>tracer = openTelemetry.getTracer(Controller.class.getName());
      <var>}

      @GetMapping(value = "/fibonacci")
    . . .
    }
    ```
    <Callout variant="tip">
      The [Tracer](https://opentelemetry.io/docs/concepts/signals/traces/#tracer) creates spans, and the static constants are set to hold two attribute keys, which you will use later to provide request-level insights in your spans. 
    </Callout>

## H. Instrument the code: Set a span attribute [#set-span-attrib]

You can create whatever spans you want, and it is up to you to annotate your spans with attributes on specific operations. The attributes you set provide additional context about the specific operation you are tracking, such as results or operation properties.

1. In your `Controller.java`, locate `fibonacci()` and add the following code to start a new span and set your first attribute:

    ```
    private long fibonacci(long n) {</var>
      <var>// Start a new span and set your first attribute</var>
      <var>var span = tracer.spanBuilder("fibonacci")</var>
              <var>.setAttribute(ATTR_N, n)</var>
              <var>.startSpan();</var>

      try {
        if (n < 1 || n > 90) {
          throw new IllegalArgumentException("n must be 1 <= n <= 90.");
        }
        // Base cases
        if (n == 1) {
          return 1;
        }
        if (n == 2) {
          return 1;
        }

        long lastLast = 1;
        long last = 2;
        for (long i = 4; i <= n; i++) {
          long cur = last + lastLast;
          lastLast = last;
          last = cur;
        }
        return last;
      } catch (IllegalArgumentException e) {
        throw e;
      }
    }
    ```
    <Callout variant="tip">
      This creates a span called `fibonacci` that captures data about the execution of this method, starting with an attribute that stores the value of n from the user's request.
    </Callout>

2. To get additional granularity in your code, add these attributes to your span to store information about successful requests:

    ```
    private long fibonacci(long n) {
      // Start a new span and set your first attribute
      var span = TRACER.spanBuilder("fibonacci").startSpan();
      span.setAttribute(ATTR_N, n);
      try {
        if (n < 1 || n > 90) {
          throw new IllegalArgumentException("n must be 1 <= n <= 90.");
        }

        // Base cases
        if (n == 1) {
          <var>span.setAttribute(ATTR_RESULT, 1);</var>
          return 1;
        }
        if (n == 2) {
          <var>span.setAttribute(ATTR_RESULT, 1);</var>
          return 1;
        }

        long lastLast = 1;
        long last = 2;
        for (long i = 4; i <= n; i++) {
          long cur = last + lastLast;
          lastLast = last;
          last = cur;
        }
        <var>span.setAttribute(ATTR_RESULT, last);</var>
        return last;
      } catch (IllegalArgumentException e) {
        throw e;
      } finally {
      }
    }
    ```

## I. Instrument the code: Record an exception

You may want to record exceptions as they happen, so we recommend you do this in conjunction with setting the span status.

1. Set your span as the current span, then set the status code to error in the event of an exception, and end the span:

    ```
      private long fibonacci(long n) {
        // Start a new span and set your first attribute
        var span = TRACER.spanBuilder("fibonacci").startSpan();
        span.setAttribute(ATTR_N, n);

        <var>// Set the span as the current span</var>
        <var>try (var scope = span.makeCurrent()) {</var>
          if (n < 1 || n > 90) {
            throw new IllegalArgumentException("n must be 1 <= n <= 90.");
          }

          // Base cases
          if (n == 1) {
            span.setAttribute(ATTR_RESULT, 1);
            return 1;
          }
          if (n == 2) {
            span.setAttribute(ATTR_RESULT, 1);
            return 1;
          }

          long lastLast = 1;
          long last = 2;
          for (long i = 4; i <= n; i++) {
            long cur = last + lastLast;
            lastLast = last;
            last = cur;
          }
          span.setAttribute(ATTR_RESULT, last);
          return last;
        } catch (IllegalArgumentException e) {
            <var>// Record the exception and set the span status</var>
            <var>span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());</var>
          throw e;
        } finally {
            <var>// End the span</var>
            <var>span.end();</var>
        }
      }
    ```
    <Callout variant="tip">
      This method throws an `IllegalArgumentException` if a user provides invalid input; when this happens, the exception is recorded as an event on the span and the span's status will be set to `ERROR`. The exception message is captured as the status description. Before moving to the next step, end the span.
    </Callout>

2. In `handleException()` in the `ErrorHandler` class, set the status for the span to `ERROR`:

    ```
    @ControllerAdvice
    private static class ErrorHandler {

      @ExceptionHandler({
              IllegalArgumentException.class,
              MissingServletRequestParameterException.class,
              HttpRequestMethodNotSupportedException.class
      })
      public ResponseEntity<Object> handleException(Exception e) {
        <var>// Set the span status and description</var>
        <var>Span.current().setStatus(StatusCode.ERROR, e.getMessage());</var>

        return new ResponseEntity<>(Map.of("message", e.getMessage()), HttpStatus.BAD_REQUEST);
      }

    }
    ```

Just like before, this sets the span's status code if the user inputs an invalid number. However, because this happens in the exception handler, rather than in `fibonacci()`, the current span is the parent span for the request. Now, when your application endpoint raises an exception, both the parent span and child span will have a span status of `ERROR`.

## J. Exercise the app to generate some traffic [#exercise]

You're finally ready to send some data to New Relic!

1. To run the application, go to the `java` directory and execute this command:

    ```
    ./gradlew bootRun
    ```

    <Callout variant="tip">
      If your terminal displays the Spring ASCII, it means your app has successfully built and is running:

      <img
        alt="Screenshot showing Spring Boot ASCII logo"
        title="Screenshot showing Spring Boot ASCII logo"
        src={opentelemetrySpringBootASCIIDisplay}
      />
    </Callout>

2. To generate traffic, open a new terminal tab, navigate to the `java` directory, and run this command:

    ```
    ./load-generator.sh
    ```

## L. View your data in New Relic [#view-data]

You'll need to wait a few minutes for your trace data to show up in your New Relic account.

1. Go to **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > APM & services**.
2. Click your new entity (service) called `getting-started-java`.
3. In the left pane's **Monitor** section, click **Distributed tracing**, and then click the **Fibonacci** trace group.
    <img
      alt="Screenshot showing the main distributed tracing page"
      title="Screenshot showing the main distributed tracing page"
      src={opentelemetryMainDistributedTracingPage}
    />
4. From there, find a trace with an error and click to open it:
    <img
      alt="Screenshot showing an error in distributed tracing"
      title="Screenshot showing an error in distributed tracing"
      src={opentelemetryDistributedTracingError}
    />
5. Once you have the trace open, click `Show in-process spans`, and then click on the resulting span, which will open up a details panel to the right. To see the exception you recorded when a user input is invalid, click on `View span events`:
    <img
      title="Screenshot of in-process spans"
      alt="Screenshot of in-process spans"
      src={opentelemetryInProcessSpans}
    />

Here's how the exception you recorded as a span event will look in New Relic:

<img
  title="Screenshot showing an exception as a span event"
  alt="Screenshot showing an exception as a span event"
  src={opentelemetryExceptiononSpanEvent}
/>

To view additional details that you set, such as the span attribute, span name, and status code, click on the **Attributes** tab. This pane is also where you can view additional metadata that is automatically collected by the instrumentation libraries you used in this guide, as well as metadata that is attached by New Relic:

<img
  title="Screenshot of the attributes tab"
  alt="Screenshot of the attributes tab"
  src={opentelemetryAttributesTab}
/>

For more details about viewing your data, see [OpenTelemetry in the New Relic UI](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page)

## (Optional) Use the SDK auto-configuration extension module [#sdk-auto-config]

The OpenTelemetry Java SDK offers a module called the SDK autoconfigure extension that lets you configure the SDK based on a set of environment variables and system properties. You can choose this option if you prefer not to manually create the OpenTelemetry instance.

<Callout variant="tip">
  If your account is based in the EU, use this endpoint: https://otlp.eu01.nr-data.net:4317.
</Callout>

In the demo application's `Application.java` file, initialize the SDK auto-configuration in your code so that the module can access the environment variables or system properties, and set up the OpenTelemetry instance by using the builders internally:

```
<var>import io.opentelemetry.sdk.autoconfigure.OpenTelemetrySdkAutoConfiguration;</var>

  public static void main(String[] args) {
    <var>// Initialize the SDK auto-configuration extension module</var>
    <var>OpenTelemetrySdk sdk = AutoConfiguredOpenTelemetrySdk.initialize()</var>
      <var>.getOpenTelemetrySdk();</var>
. . .
```

See the examples below for running via the JDK or Docker compose.

### Run via JDK [#jdk]

1. Export the following environment variables, then run the app with the command below:

    ```
    export OTEL_EXPORTER_OTLP_HEADERS=api-key=<your_license_key>
    export OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net:4317
    export OTEL_SERVICE_NAME=getting-started-java
    export OTEL_RESOURCE_ATTRIBUTES=service.instance.id=1234
    export OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT=4095
    export OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE=DELTA
    export OTEL_EXPORTER_OTLP_METRICS_DEFAULT_HISTOGRAM_AGGREGATION=EXPONENTIAL_BUCKET_HISTOGRAM
    export OTEL_LOGS_EXPORTER=otlp
    export OTEL_EXPORTER_OTLP_COMPRESSION=gzip
    export OTEL_EXPERIMENTAL_EXPORTER_OTLP_RETRY_ENABLED=true
    export OTEL_EXPERIMENTAL_RESOURCE_DISABLED_KEYS=process.command_line
    ```
2. Run the app with the following:

    ```
    ./gradlew bootRun
    ```

Some of these are optional settings that we recommend as part of our [best practices](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-overview/). For additional information about these environment variables, see [automatic base instrumentation](#initial-instrum).

## Run via Docker [#docker-compose]

To use Docker, you'd need to add a `Dockerfile` and `docker-compose.yaml` files to the project.

In the application `java` directory, create the `docker-compose.yaml` file and configure the following SDK values:

```
  appathon-java:
    build: ./java
    ports:
      - "8081:8080"
    environment:
      OTEL_SERVICE_NAME: "getting-started-java"
      OTEL_RESOURCE_ATTRIBUTES: service.instance.id=1234
      OTEL_EXPORTER_OTLP_ENDPOINT: https://otlp.nr-data.net:4317
      OTEL_EXPORTER_OTLP_HEADERS: "api-key=${NEW_RELIC_API_KEY}"
      OTEL_EXPORTER_OTLP_COMPRESSION: gzip
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: 4095
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE=DELTA
      OTEL_EXPORTER_OTLP_METRICS_DEFAULT_HISTOGRAM_AGGREGATION=EXPONENTIAL_BUCKET_HISTOGRAM
      OTEL_LOGS_EXPORTER=otlp
      OTEL_EXPERIMENTAL_EXPORTER_OTLP_RETRY_ENABLED=true
      OTEL_EXPERIMENTAL_RESOURCE_DISABLED_KEYS=process.command_line
```

`OpenTelemetrySdkAutoConfiguration` looks for these variables in the Docker container's environment and applies them at runtime.

Make sure to export your license key as `NEW_RELIC_API_KEY`.

Return to the [instrumentation](#initial-instrum) steps in the tutorial above to continue the setup.


---
title: 'OpenTelemetry tutorials: Instrument a sample Java app'
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: You can set up OpenTelemetry to monitor a simple Java app.
---

import opentelemetrySpringBootASCIIDisplay from 'images/opentelemetry_screenshot-crop_Spring-Boot-ASCII-display.png'

import opentelemetryMainDistributedTracingPage from 'images/opentelemetry_screenshot-crop_main-distributed-tracing-page.png'

import opentelemetryDistributedTracingError from 'images/opentelemetry_screenshot-crop_distributed-tracing-error.png'

import opentelemetryInProcessSpans from 'images/opentelemetry_screenshot-crop_in-process-spans.png'

import opentelemetryExceptiononSpanEvent from 'images/opentelemetry_screenshot-crop_exception-on-span-event.png'

import opentelemetryAttributesTab from 'images/opentelemetry_screenshot-crop_attributes-tab.png'

import opentelemetryMetricsExplorerMain from 'images/opentelemetry_screenshot-crop_metrics-explorer-main.png'

import opentelemetryMetricsExplorerDimensions from 'images/opentelemetry_screenshot-crop_metrics-explorer-dimensions.png'

import opentelemetryJvmsPageMain from 'images/opentelemetry_screenshot-crop_jvms-page-main.png'

import opentelemetryCompareJvmInstances from 'images/opentelemetry_screenshot-full_compare-jvm-instances.png'

import opentelemetryJvmColorCodedComparison from 'images/opentelemetry_screenshot-full_jvm-color-coded-comparison.png'

import opentelemetryMainLogsPage from 'images/opentelemetry_screenshot-full_main-logs-page.png'

import opentelemetryLogsinTerminal from 'images/opentelemetry_screenshot-full_logs-in-terminal.png'

import opentelemetryLogDetailsWithTrace from 'images/opentelemetry_screenshot-full_log-details-with-trace.png'

import opentelemetryTraceRelatedtoLog from 'images/opentelemetry_screenshot-full_trace-related-to-log.png'

import opentelemetryTraceWaterfallFromLog from 'images/opentelemetry_screenshot-full_trace-waterfall-from-log.png'

import opentelemetryLogCapturedinTraceSpan from 'images/opentelemetry_screenshot-full_log-captured-in-trace-span.png'





Try out this Java tutorial to see what the New Relic platform can do with your OTLP data. You can quickly learn how to configure your OpenTelemetry SDK to optimize your observability experience in New Relic. You'll do all this using a demo Spring application that generates the nth number in the Fibonacci sequence.

You'll find three tracks below to help you get acquainted with New Relic and OpenTelmentry. Try out the tracks that are interesting to you:

* [Run our pre-instrumented program:](#pre-instrum) This is the fastest way to send some demo data to New Relic and see how it is displayed in the UI. This demo app has pre-loaded instrumentation and SDK configurations that follow our [best practices](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-overview/) to generate and export metrics, logs, and traces. You can inspect our code and apply relevant sections to your own apps.
* [Use the OpenTelemetry Java agent:](#java-agent) Instead of using our pre-instrumentated demo app, you can use the OpenTelemetry Java agent to automatically monitor our demo app. You don't need to open the demo code and make any changes&mdash;just install and run the agent alongside the app.
* [Instrument the demo app manually:](#manual-instrum) In this track, you'll roll up your sleeves and tinker with the engine of the car. This is the approach to take if you want to have the most control over what telemetry is reported and want to see details about how it's done. You'll manually insert instrumentation into our demo app to capture telemetry and you'll configure the SDK to send that data to New Relic.

## Requirements [#requirements]

Before you get started, make sure you have the following:

* A New Relic account: Sign up for a [free account](https://newrelic.com/signup) if you don't already have one.
* Java 17 or higher: If you don't already have this, see [these download options](https://www.java.com/en/download/manual.jsp).
* IntelliJ IDEA: We recommend that you use the IntelliJ IDE while completing this guide. If you don't have IntelliJ, you can download the [free community version](https://www.jetbrains.com/help/idea/installation-guide.html#requirements).

## Run our pre-instrumented program [#pre-instrum]

This is a great option if you want us do the instrumentation so you can quickly see what's it's like to send data to New Relic and view it in our UI.

1. Clone the demo app and navigate to the following directory:
    ```
    git clone git@github.com:newrelic/newrelic-opentelemetry-examples.git
    cd newrelic-opentelemetry-examples/getting-started-guides/java/Instrumented
    ```
2. In your terminal, set these two environment variables to send data to your New Relic account:
    ```
    export OTEL_EXPORTER_OTLP_HEADERS=api-key=INSERT_YOUR_NEW_RELIC_LICENSE_KEY
    export OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net:4317

    ```
    * Make sure to use your [ingest license key](https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/#license-key).
    * If your account is based in the EU, set the endpoint to: https://otlp.eu01.nr-data.net:4317

3. Set this environment variable to name the demo app:
    ```
    export OTEL_SERVICE_NAME=getting-started-java
    ```
4. In the `java/Instrumented/` directory, run the application:
    ```
    ./gradlew bootRun
    ```
5. Open a new terminal and exercise the application from the `Instrumented/java` directory by running this command:
    ```
    ./load-generator.sh
    ```

    <Callout variant="tip">
      Alternatively, you can reach the endpoint in the browser at this URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Replace `INSERT_A_VALUE` with value from 1 to 90. To generate an error, insert an integer outside the valid range.
    </Callout>

6. Go to **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > APM & services**.
7. Click your new entity (service) called `getting-started-java` and explore the UI. For more tips about what to look for in the UI, see [View your data in New Relic](#view-data).
8. When you're finished looking at your data in the UI, shut down the application by pressing CONTROL+C in both terminal sessions.

## Use the OpenTelemetry Java agent [#java-agent]

OpenTelemetry provides an agent that automatically instruments your Java apps and doesn't require you to  modify your source code. The agent is a quick way for you to get started so you can get sample data into New Relic.

The auto-instrumentation agent is a JAR file that dynamically injects bytecode to capture telemetry from popular libraries and frameworks. You can also use it to capture data such as inbound requests, outbound HTTP calls, and database calls. It can be attached to any Java 8+ application.

<Callout variant="tip">
  See the [official documentation](https://opentelemetry.io/docs/instrumentation/java/automatic/) for additional configuration options.
</Callout>

To monitor our demo app with the OpenTelemetry Java agent:

1. Download the [agent JAR file](https://github.com/open-telemetry/opentelemetry-java-instrumentation/releases/latest/download/opentelemetry-javaagent.jar), which contains the agent and instrumentation libraries. Place it in your preferred directory and note the path, which you will use later.
2. If you haven't already done so, complete the following:
    ```
    git clone git@github.com:newrelic/newrelic-opentelemetry-examples.git
    cd newrelic-opentelemetry-examples/getting-started-guides/java/Uninstrumented
    ```
3. Build the demo app with this command:
    ```
    ./gradlew build
    ```
    <Callout variant="tip">
      After a successful build, you will find the resulting application JAR file in `Uninstrumented/build/libs`.
    </Callout>

4. Export the following environment variables to configure the agent. Click on each for details:

    <CollapserGroup>
      <Collapser
        className="freq-link"
        id="exp-bucket-hist"
        title="OTEL_EXPORTER_OTLP_HEADERS=api-key=YOUR_LICENSE_KEY"
      >
        Headers: This determines which New Relic account your data will be sent to. Replace `YOUR_LICENSE_KEY` with your [ingest license key](https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/#license-key).
      </Collapser>
      <Collapser
        className="freq-link"
        id="temp"
        title="OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net:4317 (For the US)"
      >
        This is the endpoint your application telemetry will be exported to. Export data to New Relic's OTLP endpoint. If you're in the EU, use this endpoint:

        OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.eu01.nr-data.net:4317
      </Collapser>
      <Collapser
        className="freq-link"
        id="service-name"
        title="OTEL_SERVICE_NAME=getting-started-java"
      >
        This is the name that associates your application telemetry with an entity in New Relic. In this tutorial we're calling it `getting-started-java`, but you could call it anything you want.
      </Collapser>
      <Collapser
        className="freq-link"
        id="instance-id"
        title="OTEL_RESOURCE_ATTRIBUTES=service.instance.id=INSERT_YOUR_OWN_ID_HERE"
      >
        Replace `INSERT_YOUR_OWN_ID_HERE` with a unique instance id. For example, you could use `1234`. For more details, see OpenTelemetry's [Resource Semantic Conventions](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/semantic_conventions/README.md#service).
      </Collapser>
      <Collapser
        className="freq-link"
        id="length-limit"
        title="OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT=4095"
      >
        Setting a limit on the maximum attribute value length will prevent span data from getting dropped if it exceeds the [New Relic limit](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-attributes/).
      </Collapser>
      <Collapser
        className="freq-link"
        id="temp2"
        title="OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE=DELTA"
      >
        New Relic supports metrics in delta temporality instead of the default of cumulative.
      </Collapser>
      <Collapser
        className="freq-link"
        id="bucket-hist"
        title="OTEL_EXPORTER_OTLP_METRICS_DEFAULT_HISTOGRAM_AGGREGATION=EXPONENTIAL_BUCKET_HISTOGRAM"
      >
        (Recommended) Histogram aggregation: Use exponential histogram instead of default explicit bucket histogram for better data compression.
      </Collapser>
      <Collapser
        className="freq-link"
        id="logs-otlp"
        title="OTEL_LOGS_EXPORTER=otlp"
      >
        Enable log export over OTLP. Log export is disabled by default.
      </Collapser>
      <Collapser
        className="freq-link"
        id="gzip"
        title="OTEL_EXPORTER_OTLP_COMPRESSION=gzip"
      >
        (Recommended) Setting gzip compression allows you to maximize the amount of data you can send per request. The New Relic maximum allowed payload size is 1MB (10^6 bytes). Gzip compression has good performance and lowers data egress.
      </Collapser>
      <Collapser
        className="freq-link"
        id="retry"
        title="OTEL_EXPERIMENTAL_EXPORTER_OTLP_RETRY_ENABLED=true"
      >
        (Recommended) Enable experimental export retry to help cope with the unreliability of the internet.
      </Collapser>
      <Collapser
        className="freq-link"
        id="disabled-keys"
        title="OTEL_EXPERIMENTAL_RESOURCE_DISABLED_KEYS=process.command_line"
      >
        (Recommended) This disables the `process.command_line` resource attribute which often exceeds the New Relic maximum attribute length limit and may contain sensitive information.
      </Collapser>
    </CollapserGroup>


5. Continue in `newrelic-opentelemetry-examples/getting-started-guides/java/Uninstrumented` to launch the agent with the app:

    <Callout variant="important">
      Replace `path/to` with the location of the JAR file you downloaded earlier.
    </Callout>
    ```
    java -javaagent:path/to/opentelemetry-javaagent.jar \
          -jar ./build/libs/fibonacci-java.jar
    ```
6. Generate traffic from the application by opening a new terminal in the same directory and running the load generator:
    ```
    ./load-generator.sh
    ```

    <Callout variant="tip">
      Alternatively, you can reach the endpoint in the browser at this URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Replace `INSERT_A_VALUE` with value from 1 to 90. To generate an error, insert an integer outside the valid range.
    </Callout>

7. Now that you've sent some data to New Relic, see our [detailed instructions](#view-data) about how to view the data in the UI.

8. When you're finished looking at your data in the UI, shut down the application by pressing CONTROL+C in both terminal sessions.


## Instrument the demo app manually [#manual-instrum]

The previous section helped you explore automatic instrumentation with the OpenTelemetry Java agent. If you prefer to have more control over the telemetry you gather, you can try out this tutorial to learn how to add custom instrumentation. Then, you'll see how to configure the OpenTelemetry SDK to export the data to New Relic, using our recommended best practices.

<Callout variant="tip">
  While you can manually configure the SDK, we will show you how to do so using the [autoconfigure option](https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions/autoconfigure), which simplifies the configuration of the SDK through environment variables and system properties.
</Callout>

### A. Download the software [#download]

If you haven't already downloaded our demo app, run the following:

```
git clone git@github.com:newrelic/newrelic-opentelemetry-examples.git
```

### B. Install dependencies [#dependencies]

To add dependencies:

1. Go to the application directory.
    ```
    cd newrelic-opentelemetry-examples/getting-started-guides/java/Uninstrumented
    ```
2. Open `build.gradle`.
3. Add the following highlighted items to the `dependencies` block (you may need to scroll down inside the code block):
        ```gradle lineHighlight=29-42
        plugins {
            id 'org.springframework.boot' version '2.7.5'
            id 'io.spring.dependency-management' version '1.1.0'
            id 'java'
        }

        java {
            toolchain {
                languageVersion = JavaLanguageVersion.of(17)
            }
        }

        repositories {
            mavenCentral()
        }

        bootRun {
            mainClass.set 'com.example.demo.Application'
        }

        configurations.all {
            exclude module: 'spring-boot-starter-logging'
        }

        dependencies {
            implementation 'org.springframework.boot:spring-boot-starter-web'
            implementation 'org.springframework.boot:spring-boot-starter-log4j2'

            // OpenTelemetry core
            implementation 'io.opentelemetry:opentelemetry-sdk-extension-autoconfigure'
            implementation platform('io.opentelemetry:opentelemetry-bom:1.20.1')
            implementation platform('io.opentelemetry:opentelemetry-bom-alpha:1.20.1-alpha')
            implementation 'io.opentelemetry:opentelemetry-api'
            implementation 'io.opentelemetry:opentelemetry-sdk'
            implementation 'io.opentelemetry:opentelemetry-exporter-otlp'
            implementation 'io.opentelemetry:opentelemetry-exporter-otlp-logs'

            // OpenTelemetry instrumentation
            implementation platform('io.opentelemetry.instrumentation:opentelemetry-instrumentation-bom-alpha:1.20.2-alpha')
            implementation 'io.opentelemetry.instrumentation:opentelemetry-runtime-metrics'
            implementation 'io.opentelemetry.instrumentation:opentelemetry-log4j-appender-2.17'
            implementation 'io.opentelemetry.instrumentation:opentelemetry-spring-webmvc-5.3'
        }
        ```

Notes:

* The `bom` (bill of materials) dependencies are used to synchronize versions of dependencies for a particular ecosystem. Since OpenTelemetry publishes a lot of Java components, these help ensure that all the versions are synchronized, whether you use just a few or a lot of them.
* The remaining dependencies provide access to the SDK, API, OTLP exporter, and instrumentation libraries.
* There is an additional configuration to exclude the spring-boot-starter-logging module. This prevents a build error message relating to `log4j-slf4j-impl cannot be present with log4j-to-slf4j`.

### C. Configure the SDK with the autoconfigure extension [#auto-config-ext]

While you can configure the SDK manually, we recommend you use the autoconfigure extension since it streamlines the process.

1. Go to the app's source code directory:
    ```
    cd src/main/java/com/example/demo
    ```
2. Open `Application.java`.
3. Insert the highlighted lines:
        ```java lineHighlight=7-12,28-31
        @SpringBootApplication
            public class Application {

                private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

                public static void main(String[] args) {
                    // Use autoconfigure to configure SDK from environment variables and system properties
                    OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                            .setResultAsGlobal(false)
                            .build()
                            .getOpenTelemetrySdk();
                    Application.openTelemetry = openTelemetrySdk;

                    // Set GlobalLoggerProvider, which is used by Log4j2 appender
                    GlobalLoggerProvider.set(openTelemetrySdk.getSdkLoggerProvider());

                    // Register runtime metrics instrumentation
                    BufferPools.registerObservers(openTelemetrySdk);
                    Classes.registerObservers(openTelemetrySdk);
                    Cpu.registerObservers(openTelemetrySdk);
                    GarbageCollector.registerObservers(openTelemetrySdk);
                    MemoryPools.registerObservers(openTelemetrySdk);
                    Threads.registerObservers(openTelemetrySdk);

                    SpringApplication.run(Application.class, args);
                }

                @Bean
                public OpenTelemetry openTelemetry() {
                    return openTelemetry;
                }

                // Add Spring WebMVC instrumentation by registering a tracing filter
                @Bean
                public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
                    return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
                }
            }
        ```
4. To optimize your New Relic experience, we recommend that you export the following environment variables. Click on each for details:

    <CollapserGroup>
      <Collapser
        className="freq-link"
        id="exp-bucket-hist"
        title="OTEL_EXPORTER_OTLP_HEADERS=api-key=YOUR_LICENSE_KEY"
      >
        Headers: This determines which New Relic account your data will be sent to. Replace `YOUR_LICENSE_KEY` with your [ingest license key](https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/#license-key).
      </Collapser>
      <Collapser
        className="freq-link"
        id="temp"
        title="OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net:4317 (For the US)"
      >
        This is the endpoint your application telemetry will be exported to. Export data to New Relic's OTLP endpoint. If you're in the EU, use this endpoint:

        OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.eu01.nr-data.net:4317
      </Collapser>
      <Collapser
        className="freq-link"
        id="service-name"
        title="OTEL_SERVICE_NAME=getting-started-java"
      >
        This is the name that associates your application telemetry with an entity in New Relic. In this tutorial we're calling it `getting-started-java`, but you could call it anything you want.
      </Collapser>
      <Collapser
        className="freq-link"
        id="instance-id"
        title="OTEL_RESOURCE_ATTRIBUTES=service.instance.id=INSERT_YOUR_OWN_ID_HERE"
      >
        Replace `INSERT_YOUR_OWN_ID_HERE` with a unique instance id. For example, you could use `1234`. For more details, see OpenTelemetry's [Resource Semantic Conventions](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/semantic_conventions/README.md#service).
      </Collapser>
      </Collapser>
      <Collapser
        className="freq-link"
        id="length-limit"
        title="OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT=4095"
      >
        Setting a limit on the maximum attribute value length will prevent span data from getting dropped if it exceeds the [New Relic limit](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-attributes/).
      </Collapser>
      <Collapser
        className="freq-link"
        id="temp2"
        title="OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE=DELTA"
      >
        New Relic supports metrics in delta temporality instead of the default of cumulative.
      </Collapser>
      <Collapser
        className="freq-link"
        id="bucket-hist"
        title="OTEL_EXPORTER_OTLP_METRICS_DEFAULT_HISTOGRAM_AGGREGATION=EXPONENTIAL_BUCKET_HISTOGRAM"
      >
        (Recommended) Histogram aggregation: Use exponential histogram instead of default explicit bucket histogram for better data compression.
      </Collapser>
      <Collapser
        className="freq-link"
        id="logs-otlp"
        title="OTEL_LOGS_EXPORTER=otlp"
      >
        Enable log export over OTLP. Log export is disabled by default.
      </Collapser>
      <Collapser
        className="freq-link"
        id="gzip"
        title="OTEL_EXPORTER_OTLP_COMPRESSION=gzip"
      >
        (Recommended) Setting gzip compression allows you to maximize the amount of data you can send per request. The New Relic maximum allowed payload size is 1MB (10^6 bytes). Gzip compression has good performance and lowers data egress.
      </Collapser>
      <Collapser
        className="freq-link"
        id="retry"
        title="OTEL_EXPERIMENTAL_EXPORTER_OTLP_RETRY_ENABLED=true"
      >
        (Recommended) Enable experimental export retry to help cope with the unreliability of the internet.
      </Collapser>
      <Collapser
        className="freq-link"
        id="disabled-keys"
        title="OTEL_EXPERIMENTAL_RESOURCE_DISABLED_KEYS=process.command_line"
      >
        (Recommended) This disables the process.command_line resource attribute which often exceeds the New Relic maximum attribute length limit and may contain sensitive information.
      </Collapser>
    </CollapserGroup>

### D. Add instrumentation libraries: traces [#library-traces]

In `Application.java`, add the highlighted instrumentation for Spring Web MVC by registering a tracing filter:

```java lineHighlight=25-29
@SpringBootApplication
public class Application {

    private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

    public static void main(String[] args) {
        // Build the SDK auto-configuration extension module
        OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                .setResultAsGlobal(false)
                .build()
                .getOpenTelemetrySdk();
        Application.openTelemetry = openTelemetrySdk;

        // Set GlobalLoggerProvider, which is used by Log4j2 appender
        GlobalLoggerProvider.set(openTelemetrySdk.getSdkLoggerProvider());

        SpringApplication.run(Application.class, args);
    }

    @Bean
    public OpenTelemetry openTelemetry() {
        return openTelemetry;
    }

    // Add Spring WebMVC instrumentation by registering a tracing filter
    @Bean
    public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
        return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
    }
}
```

### E. Add instrumentation libraries: metrics [#library-metrics]

Generate and collect metrics about your Java runtime by registering the following in the `Application.java` file. Insert the highlighted lines below:

```java lineHighlight=17-23
@SpringBootApplication
public class Application {

    private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

    public static void main(String[] args) {
        // Build the SDK auto-configuration extension module
        OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                .setResultAsGlobal(false)
                .build()
                .getOpenTelemetrySdk();
        Application.openTelemetry = openTelemetrySdk;

        // Set GlobalLoggerProvider, which is used by Log4j2 appender
        GlobalLoggerProvider.set(openTelemetrySdk.getSdkLoggerProvider());

        // Register runtime metrics instrumentation
        BufferPools.registerObservers(openTelemetrySdk);
        Classes.registerObservers(openTelemetrySdk);
        Cpu.registerObservers(openTelemetrySdk);
        GarbageCollector.registerObservers(openTelemetrySdk);
        MemoryPools.registerObservers(openTelemetrySdk);
        Threads.registerObservers(openTelemetrySdk);

        SpringApplication.run(Application.class, args);
    }

    @Bean
    public OpenTelemetry openTelemetry() {
        return openTelemetry;
    }

    // Add Spring WebMVC instrumentation by registering a tracing filter
    @Bean
    public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
        return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
    }
}
```

### F. Add instrumentation libraries: logs [#library-logs]

This demo application is configured to use the `OpenTelemetryAppender` (via `log4j.xml`), which uses `GlobalLoggerProvider`. Setting `GlobalLoggerProvider` wires up the `OpenTelemetryAppender` to the Log SDK that is configured using autoconfigure here:

1. Open `Application.java`.
2. Insert the following highlighted lines.
        ```java lineHighlight=14-15
        @SpringBootApplication
        public class Application {

            private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

            public static void main(String[] args) {
                // Build the SDK auto-configuration extension module
                OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                        .setResultAsGlobal(false)
                        .build()
                        .getOpenTelemetrySdk();
                Application.openTelemetry = openTelemetrySdk;

                // Set GlobalLoggerProvider, which is used by Log4j2 appender
                GlobalLoggerProvider.set(openTelemetrySdk.getSdkLoggerProvider());

                // Register runtime metrics instrumentation
                BufferPools.registerObservers(openTelemetrySdk);
                Classes.registerObservers(openTelemetrySdk);
                Cpu.registerObservers(openTelemetrySdk);
                GarbageCollector.registerObservers(openTelemetrySdk);
                MemoryPools.registerObservers(openTelemetrySdk);
                Threads.registerObservers(openTelemetrySdk);

                SpringApplication.run(Application.class, args);
            }

            @Bean
            public OpenTelemetry openTelemetry() {
                return openTelemetry;
            }

            // Add Spring WebMVC instrumentation by registering a tracing filter
            @Bean
            public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
                return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
            }
        }
        ```

3. Create a directory called `resources` in `Uninstrumented/src/main`.
4. In this new directory, create a file called `log4j2.xml` with the following contents:
        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <Configuration status="WARN" packages="io.opentelemetry.instrumentation.log4j.appender.v2_17">
          <Appenders>
            <Console name="ConsoleAppender" target="SYSTEM_OUT" follow="true">
              <PatternLayout pattern="%d{yyyy-mm-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
            </Console>
            <OpenTelemetry name="OpenTelemetryAppender" />
          </Appenders>
          <Loggers>
            <Root level="info">
              <AppenderRef ref="OpenTelemetryAppender" />
              <AppenderRef ref="ConsoleAppender" />
            </Root>
          </Loggers>
        </Configuration>
        ```
    <Callout variant="tip">
      The `packages=...` section of this line allows Log4J to find and configure the `OpenTelemetryAppender`. The source code is [here] (https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/instrumentation/log4j/log4j-appender-2.17/library) and was added as a dependency via `io.opentelemetry.instrumentation:opentelemetry-log4j-appender-2.17`)
    </Callout>

### G. Custom trace instrumentation: Create span attribute constants [#custom-attribs]

Each trace is made up of spans, which represent a logical unit of work or an operation within a particular request. The code below demonstrates:

* Static constants to hold attribute keys that can be used to provide request-level insights in your spans
* How to initialize a [Tracer](https://opentelemetry.io/docs/concepts/signals/traces/#tracer), which creates spans

Insert the following highlighted lines into `Controller.java`:

```java lineHighlight=4-14
@RestController
public class Controller {

    // Attribute constants
    private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
    private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");

    private final Tracer tracer;

    @Autowired
    Controller(OpenTelemetry openTelemetry) {
        // Initialize tracer
        tracer = openTelemetry.getTracer(Controller.class.getName());
    }

    @GetMapping(value = "/fibonacci")
. . .
}
```

### H. Custom trace instrumentation: Create a custom span [#cust-span]

You can create whatever spans you want, and it is up to you to annotate your spans with attributes on specific operations. The attributes you set will provide additional context about the specific operation you are tracking, such as results or operation properties.

1. In `Controller.java`, insert these highlighted lines to start a new span called `fibonacci` that does the following:
    * Captures data about the execution of this method
    * Sets an attribute that stores the value of n from the user's request
    ```java lineHighlight=2-5
        private long fibonacci(long n) {
            // Start a new span and set your first attribute
            var span = tracer.spanBuilder("fibonacci")
                    .setAttribute(ATTR_N, n)
                    .startSpan();
    . . .
        }
    ```
2. Add granular details into your code by adding these attributes to your span for storing information about successful requests:
        ```java lineHighlight=13,17,28
        private long fibonacci(long n) {
            // Start a new span and set your first attribute
            var span = tracer.spanBuilder("fibonacci")
                    .setAttribute(ATTR_N, n)
                    .startSpan();

            try {
                if (n < 1 || n > 90) {
                    throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                }
                // Base cases
                if (n == 1) {
                    span.setAttribute(ATTR_RESULT, 1);
                    return 1;
                }
                if (n == 2) {
                    span.setAttribute(ATTR_RESULT, 1);
                    return 1;
                }

                long lastLast = 1;
                long last = 2;
                for (long i = 4; i <= n; i++) {
                    long cur = last + lastLast;
                    lastLast = last;
                    last = cur;
                }
                span.setAttribute(ATTR_RESULT, last);
                return last;
            } catch (IllegalArgumentException e) {
                throw e;
            }
        }
        ```

### I. Custom trace instrumentation: Record an exception [#span-exception]

You may want to record exceptions as they happen. We recommend you do this in conjunction with setting the span status. First, set your span as the current span, set the status code to error in the event of an exception, and then end the span:

```java lineHighlight=7,8,32-33,35-38
private long fibonacci(long n) {
    // Start a new span and set your first attribute
    var span = tracer.spanBuilder("fibonacci")
            .setAttribute(ATTR_N, n)
            .startSpan();

    // Set the span as the current span
    try (var scope = span.makeCurrent()) {
        if (n < 1 || n > 90) {
            throw new IllegalArgumentException("n must be 1 <= n <= 90.");
        }
        // Base cases
        if (n == 1) {
            span.setAttribute(ATTR_RESULT, 1);
            return 1;
        }
        if (n == 2) {
            span.setAttribute(ATTR_RESULT, 1);
            return 1;
        }

        long lastLast = 1;
        long last = 2;
        for (long i = 4; i <= n; i++) {
            long cur = last + lastLast;
            lastLast = last;
            last = cur;
        }
        span.setAttribute(ATTR_RESULT, last);
        return last;
    } catch (IllegalArgumentException e) {
        // Record the exception and set the span status
        span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
        throw e;
    } finally {
        // End the span
        span.end();
    }
}
```

This method throws an `IllegalArgumentException` if a user provides invalid input. When this happens, the exception is recorded as an event on the span and the span's status will be set to `ERROR`. The exception message is captured as the status description. The exception will be recorded as an event on the span where it occurs.

Finally, in `handleException()` in the `ErrorHandler` class, set the status for the span to `ERROR` with these highlighted lines:

```java lineHighlight=10-11
@ControllerAdvice
private static class ErrorHandler {

    @ExceptionHandler({
            IllegalArgumentException.class,
            MissingServletRequestParameterException.class,
            HttpRequestMethodNotSupportedException.class
    })
    public ResponseEntity<Object> handleException(Exception e) {
        // Set the span status and description
        Span.current().setStatus(StatusCode.ERROR, e.getMessage());
        return new ResponseEntity<>(Map.of("message", e.getMessage()), HttpStatus.BAD_REQUEST);
    }

}
```
As in the previous step, this sets the span's status code if the user inputs an invalid number. However, because this happens in the exception handler, rather than in `fibonacci()`, the current span is the parent span for the request. This parent span comes from the Spring Web MVC instrumentation added via the filter in the Application class. Now, when your application endpoint raises an exception, both the parent span and child span will have a span status of `ERROR`.

### J. Custom metric instrumentation: Add a custom metric counter [#metrics-cust]

Metrics are a telemetry data type that are really helpful because they combine individual measurements into aggregations, and produce data that is constant as a function of system load. You can use this data in conjunction with spans to help spot trends and provide application runtime telemetry. You can also annotate any metric with attributes to help describe what subdivision of the measurements the metric represents.

The OpenTelemetry metrics API defines a number of instruments, which record measurements that are aggregated by the metrics SDK and exported out of process. There are two types of instruments:

* Synchronous: These instruments record measurements as they occur
* Asynchronous: These instruments register a callback, which is invoked only once per collection and do not have associated context

<Callout variant="tip">
  If you have any questions about the status of metric in the OpenTelemetry project, see the [signal statuses](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases).
</Callout>

Complete the following to add a custom counter:

1. Instantiate a boolean attribute for your custom metric and initialize a metrics instrument.
    <Callout variant="tip">
      In this case, we are using a [LongCounter](https://opentelemetry.io/docs/instrumentation/java/manual/#metrics), which records only positive values and is useful for counting things, such as the number of bytes sent over a network. By default, counter measurements are aggregated to montonic (always increasing) sums.
    </Callout>
        ```java lineHighlight=7,10,16-18
        @RestController
        public class Controller {

           // Attribute constants
            private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
            private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");
            private static final AttributeKey<Boolean> ATTR_VALID_N = AttributeKey.booleanKey("fibonacci.valid.n");

            private final Tracer tracer;
            private final LongCounter myCounter;

            @Autowired
            Controller(OpenTelemetry openTelemetry) {
                // Initialize tracer
                tracer = openTelemetry.getTracer(Controller.class.getName());
                // Initialize instrument
                Meter meter = openTelemetry.getMeter(Controller.class.getName());
                myCounter = meter.counterBuilder("fibonacci.invocations").setDescription("Measures the number of times the fibonacci method is invoked.").build();
            }
        . . .
        }
        ```
2. Insert the following highlighed lines so your custom counter can capture valid and invalid inputs, as well as the number of times each occurs.
        ```java lineHighlight=30-31,36-37
        private long fibonacci(long n) {
            // Start a new span and set your first attribute
            var span = tracer.spanBuilder("fibonacci")
                    .setAttribute(ATTR_N, n)
                    .startSpan();

            // Set the span as the current span
            try (var scope = span.makeCurrent()) {
                if (n < 1 || n > 90) {
                    throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                }
                // Base cases
                if (n == 1) {
                    span.setAttribute(ATTR_RESULT, 1);
                    return 1;
                }
                if (n == 2) {
                    span.setAttribute(ATTR_RESULT, 1);
                    return 1;
                }

                long lastLast = 1;
                long last = 2;
                for (long i = 4; i <= n; i++) {
                    long cur = last + lastLast;
                    lastLast = last;
                    last = cur;
                }
                span.setAttribute(ATTR_RESULT, last);
                // Counter to capture valid inputs and the number of times each occurs
                myCounter.add(1, Attributes.of(ATTR_VALID_N, true));
                return last;
            } catch (IllegalArgumentException e) {
                // Record the exception and set the span status
                span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
                // Counter to capture invalid inputs and the number of times each occurs
                myCounter.add(1, Attributes.of(ATTR_VALID_N, false));
                throw e;
            } finally {
                // End the span
                span.end();
            }
        }
        ```

### K. Custom log instrumentation [#cust-log]

The status of the logs signal in OpenTelemetry Java is currently [experimental](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases). Log messages are managed by the root handler in your app, which will send logs of `INFO` level and higher to the console by default. However, you can modify the logger behavior by changing the logging level, including for specific classes, or installing a custom handler or filter.

#### Initialize the logger [#initialize-logger]

Initialize the logger (as previously stated, this is from the `java.util.logging` library. The Logger is not an OpenTelemetry component, but the application has been configured to send Log4j logs to the OpenTelemetry Log SDK):

```java lineHighlight=4-5
@RestController
public class Controller {

  // Logger (note that this is not an OTel component)
  private static final Logger LOGGER = LogManager.getLogger(Controller.class);

  // Attribute constants
  private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
  private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");
  private static final AttributeKey<Boolean> ATTR_VALID_N = AttributeKey.booleanKey("fibonacci.valid.n");
. . .
}
```

#### Add custom log messages [#cust-log-messages]

You can now use the logger to record:

* The result of a valid input, along with the value of that result
* When no output was recorded

Insert the following highlighted lines:

```java lineHighlight=32-33,40-41
private long fibonacci(long n) {
  // Start a new span and set your first attribute
  var span = tracer.spanBuilder("fibonacci")
          .setAttribute(ATTR_N, n)
          .startSpan();

  // Set the span as the current span
  try (var scope = span.makeCurrent()) {
    if (n < 1 || n > 90) {
      throw new IllegalArgumentException("n must be 1 <= n <= 90.");
    }
    // Base cases
    if (n == 1) {
      span.setAttribute(ATTR_RESULT, 1);
      return 1;
    }
    if (n == 2) {
      span.setAttribute(ATTR_RESULT, 1);
      return 1;
    }

    long lastLast = 1;
    long last = 2;
    for (long i = 4; i <= n; i++) {
      long cur = last + lastLast;
      lastLast = last;
      last = cur;
    }
    span.setAttribute(ATTR_RESULT, last);
    // Counter to capture valid inputs and the number of times each occurs
    myCounter.add(1, Attributes.of(ATTR_VALID_N, true));
    // Log the result of a valid input
    LOGGER.info("An output of " + last + " was recorded");
    return last;
  } catch (IllegalArgumentException e) {
    // Record the exception and set the span status
    span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
    // Counter to capture invalid inputs and the number of times each occurs
    myCounter.add(1, Attributes.of(ATTR_VALID_N, false));
    // Log when no output was recorded
    LOGGER.info("An exception occurred and no output was recorded");
    throw e;
  } finally {
    // End the span
    span.end();
  }
}
```

### L. Exercise the app to generate some traffic [#exercise-app]

You're ready to send some data to New Relic!

1. Go to the directory `getting-started-guide/java/Uninstrumented` and run this command:
    ```
    ./gradlew bootRun
    ```

    <Callout variant="tip">
      If your terminal displays the Spring ASCII, it means your app has successfully built and is running:

      <img
        alt="Screenshot showing Spring Boot ASCII logo"
        title="Screenshot showing Spring Boot ASCII logo"
        src={opentelemetrySpringBootASCIIDisplay}
      />
    </Callout>
2. Generate traffic from the application by opening a new terminal in the `java` directory and running the load generator:
    ```
    ./load-generator.sh
    ```
    <Callout variant="tip">
      Alternatively, you can reach the endpoint in the browser at this URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Replace `INSERT_A_VALUE` with value from 1 to 90. To generate an error, insert an integer outside the valid range.
    </Callout>

3. Now that you've sent some data to New Relic, see our [detailed instructions](#view-data) about how to view the data in the UI.

### M. View your data in New Relic [#view-data]

You'll need to wait a few minutes for your trace data to show up in your New Relic account.

To get started with the UI, do the following:

1. Go to **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > APM & services**.
2. Click your new entity (service) called `getting-started-java`.
3. Check out the details in the sections for each data type.

### Traces [#traces]

Once you've reached the `getting-started-java` entity in New Relic:


1. In the left pane's **Monitor** section, click **Distributed tracing**, and then click the **Fibonacci** trace group.
    <img
      alt="Screenshot showing the main distributed tracing page"
      title="Screenshot showing the main distributed tracing page"
      src={opentelemetryMainDistributedTracingPage}
    />
2. From there, find a trace with an error and click to open it:
    <img
      alt="Screenshot showing an error in distributed tracing"
      title="Screenshot showing an error in distributed tracing"
      src={opentelemetryDistributedTracingError}
    />
3. Once you have the trace open, click `Show in-process spans`, and then click on the resulting span, which will open up a details panel to the right. To see the exception you recorded when a user input is invalid, click on `View span events`:
    <img
      title="Screenshot of in-process spans"
      alt="Screenshot of in-process spans"
      src={opentelemetryInProcessSpans}
    />

If you completed the manual instrumentation tutorial, here's how the exception you recorded as a span event will look in New Relic:

<img
  title="Screenshot showing an exception as a span event"
  alt="Screenshot showing an exception as a span event"
  src={opentelemetryExceptiononSpanEvent}
/>

To view additional details that you set, such as the span attribute, span name, and status code, click on the **Attributes** tab. This pane is also where you can view additional metadata that is automatically collected by the instrumentation libraries you used in this guide, as well as metadata that is attached by New Relic:

<img
  title="Screenshot of the attributes tab"
  alt="Screenshot of the attributes tab"
  src={opentelemetryAttributesTab}
/>

For more details about viewing your data, see [OpenTelemetry in the New Relic UI](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page)


### Metrics [#metrics]

Once you've reached the `getting-started-java` entity in New Relic, you can see a list of all collected metrics, such as runtime metrics (JVMs) and your custom counter attributes.

#### Metrics explorer [#metrics-explorer]

This is a tool that allows you to see a list of your metrics.

1. In the left pane, select **Data > Metrics explorer**, and then select `fibonacci.invocations`.

    <img
      title="Screenshot showing metrics explorer"
      alt="Screenshot showing metrics explorer"
      src={opentelemetryMetricsExplorerMain}
    />
2. Under **Dimensions**, view the attributes you collected along with your custom metric, and then click on **fibonacci.valid.n**.

    <img
      title="Screenshot showing the total number of invocations of fibonacci function"
      alt="Screenshot showing the total number of invocations of fibonacci function"
      src={opentelemetryMetricsExplorerDimensions}
    />

Learn more about the metrics explorer view [here](docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-metrics-explorer-page).


#### JVMs [#jvms]

You can also view visualizations of your Java runtime metrics, including throughput, memory usage, and garbage collection time per minute, by heading to the JVM page:

<img
  title="Screenshot of the main JVMs page"
  alt="Screenshot of the main JVMs page"
  src={opentelemetryJvmsPageMain}
/>

You can view the metrics for a single instance, or select multiple instances to compare them:

<img
  title="Screenshot of how to compare JVM instances"
  alt="Screenshot of how to compare JVM instances"
  src={opentelemetryCompareJvmInstances}
/>

Here is what you will see after selecting your instances and clicking **Compare**, where each instance is color coded for easy identification:

<img
  title="Screenshot showing the color-coded JVM comparison"
  alt="Screenshot showing the color-coded JVM comparison"
  src={opentelemetryJvmColorCodedComparison}
/>

To learn more about the JVMs view, see [here](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-jvms-page/).

### Logs [#logs]

Here is where to access your logs:

<img
  title="Screenshot showing the main logs page"
  alt="Screenshot showing the main logs page"
  src={opentelemetryMainLogsPage}
/>

You will also see logs in your terminal:

<img
  title="Screenshot showing logs in a terminal"
  alt="Screenshot showing logs in a terminal"
  src={opentelemetryLogsinTerminal}
/>

Back in your logs view, select a log, and you will see a pane open up with the log message and additional attributes that were collected, such as the associated span and trace ids, as well as metadata injected by New Relic:

<img
  title="Screenshot showing log details with trace"
  alt="Screenshot showing log details with trace"
  src={opentelemetryLogDetailsWithTrace}
/>

You can navigate to the correlated distributed trace by clicking this little blue icon:

<img
  title="Screenshot showing how to find correlated trace"
  alt="Screenshot showing how to find correlated trace"
  src={opentelemetryTraceRelatedtoLog}
/>

This will open a pane that displays the correlated trace, where you can view more details about the trace. For more about this page, see [OpenTelemetry in the UI: Distributed tracing page](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page/) and [Understand and use the distributed tracing UI](https://docs.newrelic.com/docs/distributed-tracing/ui-data/understand-use-distributed-tracing-ui/):

<img
  title="Screenshot showing the trace waterfall from the logs section"
  alt="Screenshot showing the trace waterfall from the logs section"
  src={opentelemetryTraceWaterfallFromLog}
/>

You can also find the correlated log from the distributed traces view. When you select a trace that has a corresponding log, you will see that indicated as a tab, and you can view the log directly from the trace without having to switch views:

<img
  title="Screenshot showing how to see log details from a trace span"
  alt="Screenshot showing how to see log details from a trace span"
  src={opentelemetryLogCapturedinTraceSpan}
/>

Learn more about the logs view [here](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-logs-page).



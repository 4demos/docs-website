---
title: 'OpenTelemetry tutorial: Manual instrumentation of Java app with metrics'
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: You can set up OpenTelemetry to monitor a simple Java app with metrics.
---

To help you see how manual instrumentation works in a simple Java app, try out this tutorial that highlights metrics.

Metrics are a telemetry data type that are really helpful because they combine individual measurements into aggregations, and produce data that is constant as a function of system load. You can use this data in conjunction with spans to help spot trends and provide application runtime telemetry. You can also annotate any metric with attributes to help describe what subdivision of the measurements the metric represents.

The OpenTelemetry metrics API defines a number of instruments, which record measurements that are aggregated by the metrics SDK and exported out of process. There are two types of instruments:

* Synchronous instruments, which record measurements as they occur and have associated distributed context
* Asynchronous instruments register a callback, which is invoked only once per collection and do not have associated context

<Callout variant="tip">
  If you have any questions about the status of metric in the OpenTelemetry project, see the [signal statuses](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases).
</Callout>

During this tutorial for generating and exporting metrics, you'll open up the demo app and add dependencies, configure a meter provider and exporter, and insert some instrumentation. Then, you'll run the app and check out the metrics in the New Relic UI.

## Requirements [#requirements]

Before you get started, make sure you have the following:

* A New Relic account: Sign up for a [free account](https://newrelic.com/signup) if you don't already have one.
* Java 8+: If you don't already have this, see [Java 8+](https://www.java.com/en/download/manual.jsp).
* IntelliJ IDEA: We recommend that you use the IntelliJ IDE while completing this guide. If you don't have IntelliJ, you can download the [free community version](https://www.jetbrains.com/help/idea/installation-guide.html#requirements).

<Callout variant="tip">
  For this Java tutorial, you have the option of using the [SDK autoconfigure extension module](https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions/autoconfigure) to configure the SDK. See [SDK auto config](#SDK-auto-config) for how to set this up. This extension only impacts the SDK configuration&mdash;you will still need to instrument the application following the instrumentation steps in this guide.
</Callout>

## A. Download the demo application [#download]

Start by cloning the demo application, which generates the nth number in the Fibonacci sequence:

```
git clone git@github.com:reese-lee/getting-started-guides.git
```

## B. Add OpenTelemetry Dependencies [#dependencies]

If you've already completed the tracing tutorial, you've adding most of these lines already&mdash;just make sure you also include the `runtime-metrics` implementation line (the second following "OpenTelemetry instrumentation"):

1. Go to the application's `java` directory.

    ```
    cd Uninstrumented/java
    ```
2. Open `build.gradle` in your preferred text editor.
3. Add the following in the `dependencies` block of the `build.gradle` file:
    ```
    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter-web'

        <var>// OpenTelemetry core</var>
        <var>implementation platform('io.opentelemetry:opentelemetry-bom:1.20.1')</var>
        <var>implementation platform('io.opentelemetry:opentelemetry-bom-alpha:1.20.1-alpha')</var>
        <var>implementation 'io.opentelemetry:opentelemetry-api'</var>
        <var>implementation 'io.opentelemetry:opentelemetry-sdk'</var>
        <var> implementation 'io.opentelemetry:opentelemetry-exporter-otlp'/var>

        <var>// OpenTelemetry instrumentation</var>
        <var>implementation platform('io.opentelemetry.instrumentation:opentelemetry-instrumentation-bom-alpha:1.20.2-alpha')</var>
        <var>implementation 'io.opentelemetry.instrumentation:opentelemetry-runtime-metrics'</var>
        <var>implementation 'io.opentelemetry.instrumentation:opentelemetry-spring-webmvc-5.3'</var>
    }
    ```

Notes:

* The `bom` (bill of materials) dependencies are used to synchronize versions of dependencies for a particular ecosystem. Since OpenTelemetry publishes a lot of Java components, these help ensure that all the versions are synchronized, whether you use just a few or a lot of them.
* The remaining dependencies provide access to the SDK, API, OTLP exporter, and instrumentation libraries.
* If you have imports optimized in your Intellij IDE, then Intellij will take care of imports for you once you've added the dependencies in your `build.gradle` file and refreshed it.

## C. Register runtime metrics instrumentation [#runtime-metrics]

Import the following dependencies and register your runtime metrics instrumentation:

1. Go to the app's source code directory:
    ```
    cd src/main/java/com/example/demo
    ```
2. Open `Application.java` and add the following to import dependencies and register your runtimne metrics instrumentation:

    ```
    public static void main(String[] args) {
      // Configure OpenTelemetry as early as possible
      var openTelemetrySdk = openTelemetrySdk();
      Application.openTelemetry = openTelemetrySdk;

      <var>// Register runtime metrics instrumentation</var>
      <var>BufferPools.registerObservers(openTelemetrySdk);</var>
      <var>Classes.registerObservers(openTelemetrySdk);</var>
      <var>Cpu.registerObservers(openTelemetrySdk);</var>
      <var>GarbageCollector.registerObservers(openTelemetrySdk);</var>
      <var>MemoryPools.registerObservers(openTelemetrySdk);</var>
      <var>Threads.registerObservers(openTelemetrySdk);</var>

      SpringApplication.run(Application.class, args);
    }
    ```

## D. Configure a meter provder [#meter-provider]

Configure a meter provider, which provides access to the meter and lets you create instrument objects to record measurements from your app. If you want to know more about meters, see [opentelemetry.io](https://opentelemetry.io/docs/reference/specification/metrics/sdk/#meterprovider).

Continue in `Application.java` and add the following.

<Callout variant="tip">
  If you have already completed the tracing tutorial, insert this under the stanza for adding the OTLP span exporter.
</Callout>

```
  private static OpenTelemetrySdk openTelemetrySdk() {
    // Environment variables for your OTLP exporters
    var newrelicLicenseKey = getEnvOrDefault("newrelicLicenseKey", Function.identity(), "");
    var newrelicOtlpEndpoint = getEnvOrDefault("newrelicOtlpEndpoint", Function.identity(), "https://otlp.nr-data.net:4317");

    // Configure resource
    var resource =
            Resource.getDefault().toBuilder()
                    .put(ResourceAttributes.SERVICE_NAME, "getting-started-java")
                    .put(ResourceAttributes.SERVICE_INSTANCE_ID, UUID.randomUUID().toString())
                    .build();
    // Configure tracer provider
    var sdkTracerProviderBuilder =
            SdkTracerProvider.builder()
                    .setResource(resource)
                    // New Relic's max attribute length is 4095 characters
                    .setSpanLimits(
                            SpanLimits.getDefault().toBuilder().setMaxAttributeValueLength(4095).build());

    // Add otlp span exporter
    var spanExporterBuilder =
            OtlpGrpcSpanExporter.builder()
                    .setEndpoint(newrelicOtlpEndpoint)
                    .setCompression("gzip")
                    .addHeader("api-key", newrelicLicenseKey);
    sdkTracerProviderBuilder.addSpanProcessor(
            BatchSpanProcessor.builder(spanExporterBuilder.build()).build());

    <var>// Configure meter provider</var>
    <var>var sdkMeterProviderBuilder = SdkMeterProvider.builder().setResource(resource);</var>

    // Bring it all together
    return OpenTelemetrySdk.builder()
            .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
            .setTracerProvider(sdkTracerProviderBuilder.build())
            .setMeterProvider(sdkMeterProviderBuilder.build())
            .build();

  }
```

## E. Instantiate environment variables [#instan-env-vars]

Instantiate the two environment variables you are going to use for your OTLP exporter. If you've already completed the tracing tutorial, you can skip this step.

In `Application.java`, add the environment variables:

```
@SpringBootApplication
public class Application {

  private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

  public static void main(String[] args) {
    // Configure OpenTelemetry as early as possible
    var openTelemetrySdk = openTelemetrySdk();
    Application.openTelemetry = openTelemetrySdk;

    SpringApplication.run(Application.class, args);
  }

  @Bean
  public OpenTelemetry openTelemetry() {
    return openTelemetry;
  }

  private static OpenTelemetrySdk openTelemetrySdk() {
    <var>// Environment variables for your OTLP exporters</var>
    <var>var newrelicLicenseKey = getEnvOrDefault("newrelicLicenseKey", Function.identity(), "");</var>
    <var>var newrelicOtlpEndpoint = getEnvOrDefault("newrelicOtlpEndpoint", Function.identity(), "https://otlp.nr-data.net:4317");</var>

    // Configure resource
    var resource =
            Resource.getDefault().toBuilder()
                    .put(ResourceAttributes.SERVICE_NAME, "getting-started-java")
                    .put(ResourceAttributes.SERVICE_INSTANCE_ID, UUID.randomUUID().toString())
                    .build();
    // Configure tracer provider
    var sdkTracerProviderBuilder =
            SdkTracerProvider.builder()
                    .setResource(resource)
                    // New Relic's max attribute length is 4095 characters
                    .setSpanLimits(
                            SpanLimits.getDefault().toBuilder().setMaxAttributeValueLength(4095).build());

    // Bring it all together
    return OpenTelemetrySdk.builder()
            .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
            .setTracerProvider(sdkTracerProviderBuilder.build())
            .build();

  }

  <var>private static <T> T getEnvOrDefault(</var>
          <var>String key, Function<String, T> transformer, T defaultValue) {</var>
    <var>return Optional.ofNullable(System.getenv(key))</var>
            <var>.filter(s -> !s.isBlank())</var>
            <var>.or(() -> Optional.ofNullable(System.getProperty(key)))</var>
            <var>.filter(s -> !s.isBlank())</var>
            <var>.map(transformer)</var>
            <var>.orElse(defaultValue);</var>
  }
}
```

## E. Configure an OTLP metrics exporter [#metrics-exporter]

This is the component that sends metrics from your application to New Relic. Continue in `Application.java`, and add this directly under the meter provider:

```
  private static OpenTelemetrySdk openTelemetrySdk() {
. . .
    // Configure meter provider
    var sdkMeterProviderBuilder = SdkMeterProvider.builder().setResource(resource);

    <var>// Add otlp metric exporter</var>
    <var>var metricExporterBuilder =</var>
        <var>OtlpGrpcMetricExporter.builder()</var>
            <var>.setEndpoint("https://otlp.nr-data.net:4317")</var>
            <var>.setCompression("gzip")</var>
            <var>.addHeader("api-key", newrelicLicenseKey)</var>
            <var>// IMPORTANT: New Relic requires metrics to be delta temporality</var>
            <var>.setAggregationTemporalitySelector(AggregationTemporalitySelector.deltaPreferred())</var>
            <var>// Use exponential histogram aggregation for histogram instruments to produce better</var>
            <var>// data</var>
            <var>.setDefaultAggregationSelector(</var>
                <var>DefaultAggregationSelector.getDefault()</var>
                    <var>.with(InstrumentType.HISTOGRAM, ExponentialHistogramAggregation.getDefault()));</var>

    return OpenTelemetrySdk.builder()
        .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
        .setTracerProvider(sdkTracerProviderBuilder.build())
        .setLogEmitterProvider(sdkLogEmitterProvider.build())
        .buildAndRegisterGlobal();
  }
```

Notes:

* `newrelicOtlpEndpoint`is how you configure where the generated data will be exported to. If your account is in the EU, use https://otlp.eu01.nr-data.net:4317.
* `newrelicLicenseKey` is how you configure which New Relic account you want your data exported to.
* Setting `gzip` compression allows you to maximize the amount of data you can send per request. The New Relic maximum allowed payload size is 1MB (10^6 bytes).
* New Relic supports metrics in delta temporality, instead of the default cumulative.
* We recommend using exponential histogram aggregation instead of the default explicit bucket histogram aggregation for better data compression.


## E. Register and build a metric reader [#reader]

This component is part of the SDK, and it enables you to register metric producers, collect metrics from metric producers, and handle SDK shutdown signals.

In `Application.java`, add this directly under the metric exporter:

```
  private static OpenTelemetrySdk openTelemetrySdk() {
. . .
    // Configure meter provider
    var sdkMeterProviderBuilder = SdkMeterProvider.builder().setResource(resource);

    // Add otlp metric exporter
    var metricExporterBuilder =
        OtlpGrpcMetricExporter.builder()
            .setEndpoint("https://otlp.nr-data.net:4317")
            .setCompression("gzip")
            .addHeader("api-key", newrelicLicenseKey)
            // IMPORTANT: New Relic requires metrics to be delta temporality
            .setAggregationTemporalitySelector(AggregationTemporalitySelector.deltaPreferred())
            // Use exponential histogram aggregation for histogram instruments to produce better
            // data and compression
            .setDefaultAggregationSelector(
                DefaultAggregationSelector.getDefault()
                    .with(InstrumentType.HISTOGRAM, ExponentialHistogramAggregation.getDefault()));
    <var>// Register and build a metric reader</var>
    <var>sdkMeterProviderBuilder.registerMetricReader(</var>
                      <var>PeriodicMetricReader.builder(metricExporterBuilder.build()).build());</var>
 }

```

## F. Return the SDK [#return-sdk]

Bring it all together by returning the meter provider. If you have already completed the traces and logs tutorials, you may already have this stanza&mdash;just make sure to add the meter provider line.

In `Application.java`, add this after the metric reader stanza:

```
  private static OpenTelemetrySdk openTelemetrySdk() {
. . .
    // Configure meter provider
    var sdkMeterProviderBuilder = SdkMeterProvider.builder().setResource(resource);

    // Add otlp metric exporter
    var metricExporterBuilder =
        OtlpGrpcMetricExporter.builder()
            .setEndpoint("https://otlp.nr-data.net:4317")
            .setCompression("gzip")
            .addHeader("api-key", newrelicLicenseKey)
            // IMPORTANT: New Relic requires metrics to be delta temporality
            .setAggregationTemporalitySelector(AggregationTemporalitySelector.deltaPreferred())
            // Use exponential histogram aggregation for histogram instruments to produce better
            // data and compression
            .setDefaultAggregationSelector(
                DefaultAggregationSelector.getDefault()
                    .with(InstrumentType.HISTOGRAM, ExponentialHistogramAggregation.getDefault()));
    // Register and build a metric reader
    sdkMeterProviderBuilder.registerMetricReader(
                      PeriodicMetricReader.builder(metricExporterBuilder.build()).build());

    <var>// Bring it all together</var>
    <var>return OpenTelemetrySdk.builder()</var>
            <var>.setMeterProvider(sdkMeterProviderBuilder.build())</var>
            <var>.build();</var>
  }

```

## G. Instrument the code: [#instrument-initial]

You are going to build a custom counter using a `LongCounter`, which records only positive values and is useful for counting things, such as the number of bytes sent over a network. By default, counter measurements are aggregated to always-increasing monotonic sums.

Go to `Controller.java` to instantiate a boolean attribute for your custom metric and initialize a metrics instrument:

<Callout variant="tip">
  If you have already done the tracing tutorial, insert this under the tracing constants.
</Callout>

```
@RestController
public class Controller {

  // Attribute constants
  private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
  private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");
  <var>private static final AttributeKey<Boolean> ATTR_VALID_N = AttributeKey.booleanKey("fibonacci.valid.n");</var>

  private final Tracer tracer;
  <var>private final LongCounter myCounter;</var>

  @Autowired
  Controller(OpenTelemetry openTelemetry) {
    // Initialize tracer
    tracer = openTelemetry.getTracer(Controller.class.getName());
    <var>// Initialize instrument</var>
    <var>Meter meter = openTelemetry.getMeter(Controller.class.getName());</var>
    <var>myCounter = meter.counterBuilder("my-custom-counter").setDescription("A counter that counts things").build();</var>
  }


}
```

## H. Add a custom counter [#custom-counter]

You will create a custom counter called `my-custom-counter` and increment by 1 each time the `fibonacci()` function runs. It will capture valid and invalid inputs, and the number of times each occurs. Place your counter below:

```
  private long fibonacci(long n) {
    // Start a new span and set your first attribute
    var span = tracer.spanBuilder("fibonacci")
            .setAttribute(ATTR_N, n)
            .startSpan();

    // Set the span as the current span
    try (var scope = span.makeCurrent()) {
      if (n < 1 || n > 90) {
        throw new IllegalArgumentException("n must be 1 <= n <= 90.");
      }
      // Base cases
      if (n == 1) {
        span.setAttribute(ATTR_RESULT, 1);
        return 1;
      }
      if (n == 2) {
        span.setAttribute(ATTR_RESULT, 1);
        return 1;
      }

      long lastLast = 1;
      long last = 2;
      for (long i = 4; i <= n; i++) {
        long cur = last + lastLast;
        lastLast = last;
        last = cur;
      }
      span.setAttribute(ATTR_RESULT, last);
      <var>// Counter to capture valid inputs and the number of times each occurs</var>
      <var>myCounter.add(1, Attributes.of(ATTR_VALID_N, true));</var>
      return last;
    } catch (IllegalArgumentException e) {
      // Record the exception and set the span status
      span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
      <var>// Counter to capture invalid inputs and the number of times each occurs</var>
      <var>myCounter.add(1, Attributes.of(ATTR_VALID_N, false));</var>
      throw e;
    } finally {
      // End the span
      span.end();
    }
  }

```

Note that the count will start at 0 when you restart your app.

## F. Create environment variables for your OTLP exporter [#env-vars]

Now, export the two environment variables you configured in your OTLP exporter. This method ensures your license key is not hardcoded. It also makes it simpler to update your OTLP endpoint.

Before you create the environment variables, keep the following in mind:

* Make sure to use your [ingest license key](https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/#license-key):
* By default, the OTLP exporter is pointed to one of [New Relic's OTLP endpoints](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-setup#review-settings). You can override it by setting a different value, for instance, if your account is based in the EU:
    * For US-based accounts: https://otlp.nr-data.net:4317
    * For EU-based accounts: https://otlp.eu01.nr-data.net:4317
* If you don't set the endpoint, the data will be exported to one of our OTLP endpoints by default, since you are setting it as the default in the code below.

Complete the following:

1. Add the following dependencies and code to `Application.java` so any environment variables you set can be picked up:

    ```
    <var>// Dependencies for resource configuration</var>
    <var>import java.util.Optional;</var>
    <var>import java.util.function.Function;</var>

    @SpringBootApplication
    public class Application {

      public static void main(String[] args) {
    . . .
      }

      private static OpenTelemetrySdk openTelemetrySdk() {
        <var>// Environment variables for your OTLP exporters</var>
        <var>var newrelicLicenseKey = getEnvOrDefault("NEW_RELIC_LICENSE_KEY", Function.identity(), "");</var>
        <var>var newrelicOtlpEndpoint = getEnvOrDefault("OTLP_HOST", Function.identity(), "https://otlp.nr-data.net:4317");</var>

        // Configure resource
    . . .
        // Bring it all together
        return OpenTelemetrySdk.builder()
            .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
            .setTracerProvider(sdkTracerProviderBuilder.build())
            .buildAndRegisterGlobal();
      }

      <var>private static <T> T getEnvOrDefault(</var>
          <var>String key, Function<String, T> transformer, T defaultValue) {</var>
        <var>return Optional.ofNullable(System.getenv(key))</var>
            <var>.filter(s -> !s.isBlank())</var>
            <var>.or(() -> Optional.ofNullable(System.getProperty(key)))</var>
            <var>.filter(s -> !s.isBlank())</var>
            <var>.map(transformer)</var>
            <var>.orElse(defaultValue);</var>
      <var>}</var>
    }
    ```

2. Run these commands in your terminal:

    ```
    export newrelicLicenseKey=<your_license_key>
    export newrelicOtlpEndpoint=https://otlp.nr-data.net:4317
    ```

## J. Exercise the app to generate some traffic [#exercise]

You're finally ready to send some data to New Relic!

1. To run the application, go to the `java` directory and execute this command:

    ```
    ./gradlew bootRun
    ```

    <Callout variant="tip">
      If your terminal displays the Spring ASCII, it means your app has successfully built and is running:
    </Callout>

2. To generate traffic, open a new terminal tab, navigate to the `java` directory, and run this command:

    ```
    ./load-generator.sh
    ```

## K. View your data in New Relic [#view-data]

You'll need to wait a few minutes for your trace data to show up in your New Relic account.

1. Go to **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > APM & services**.
2. Click your entity (service).
3. In the left pane, click **Metrics explorer** to view your counter metrics.

For more details about viewing your data, see [OpenTelemetry in the New Relic UI](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page)
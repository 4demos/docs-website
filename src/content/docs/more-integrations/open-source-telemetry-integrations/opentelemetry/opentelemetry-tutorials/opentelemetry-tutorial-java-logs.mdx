---
title: 'OpenTelemetry tutorial: Manual instrumentation of Java app with logs'
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: You can set up OpenTelemetry to monitor a simple Java app with logs.
---

To help you see how manual instrumentation works in a simple Java app, try out this tutorial that highlights logs.

Log messages are handled by the root handler in your app, which will send logs of `INFO` level and higher to the console by default. However, you can modify the logger behavior by changing the logging level, including for specific classes, or installing a custom handler or filter.

<Callout variant="important">
  The status of the logs signal in OpenTelemetry Java is currently [experimental](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases). OpenTelemetry Java utilizes [java.util.logging](https://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html) to log information about OpenTelemetry, such as errors and warnings related to misconfiguration or export failure.
</Callout>

During this tutorial for generating and exporting logs, you'll open up the demo app and add dependencies, configure a log emitter, and insert some instrumentation. Then, you'll run the app and check out the traces in the New Relic UI.

## A. Download the demo application [#download]

Start by cloning the demo application, which generates the nth number in the Fibonacci sequence:

```
git clone git@github.com:reese-lee/getting-started-guides.git
```
## B. Add OpenTelemetry dependencies [#add-depend]

To add dependencies:

1. Go to the application's `java` directory.

    ```
    cd Uninstrumented/java
    ```
2. Open `build.gradle` in your preferred text editor.
3. Add the following in the `dependencies` block of the `build.gradle` file:
    ```
    dependencies {
    . . .
        <var>implementation 'io.opentelemetry:opentelemetry-exporter-otlp-logs'</var>
        <var>implementation 'io.opentelemetry:opentelemetry-exporter-logging'</var>
        <var>implementation 'io.opentelemetry.instrumentation:opentelemetry-log4j-appender-2.17'</var>
        <var>implementation 'org.springframework.boot:spring-boot-starter-log4j2'</var>
    }
    ```
4. Insert the following configuration to exclude the `spring-boot-starter-logging module`; otherwise, you will encounter a build error message saying `log4j-slf4j-impl cannot be present with log4j-to-slf4j`:

    ```
    bootRun {
        mainClass.set 'com.example.demo.Application'
    }

    <var>configurations.all {</var>
        <var>exclude module: 'spring-boot-starter-logging'</var>
    }

    dependencies {
    . . .
    }

    ```

## C. Add a log4j2 file [#log4j2]

You'll be using log4j2 to log application messages. Complete the following:

1. Create a new directory called `resources` in the same level as the `java` directory.
2. Add a new file called `log4j2.xml` in the new `resources` directory with the following content:

    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <Configuration status="WARN" packages="io.opentelemetry.instrumentation.log4j.appender.v2_17">
      <Appenders>
        <Console name="ConsoleAppender" target="SYSTEM_OUT" follow="true">
          <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>
        <OpenTelemetry name="OpenTelemetryAppender" />
      </Appenders>
      <Loggers>
        <Root level="info">
          <AppenderRef ref="OpenTelemetryAppender" />
          <AppenderRef ref="ConsoleAppender" />
        </Root>
      </Loggers>
    </Configuration>
    ```

## D. Initialize the log4j2 appender [#appender]

In `Application.java`, add the following:

```
// Dependencies for logs
<var>import io.opentelemetry.sdk.logs.LogLimits;</var>
<var>import io.opentelemetry.sdk.logs.SdkLogEmitterProvider;</var>
<var>import io.opentelemetry.sdk.logs.export.BatchLogProcessor;</var>
<var>import io.opentelemetry.exporter.logging.LoggingMetricExporter;</var>
<var>import io.opentelemetry.exporter.logging.LoggingSpanExporter;</var>
<var>import io.opentelemetry.exporter.otlp.logs.OtlpGrpcLogExporter;</var>
<var>import io.opentelemetry.instrumentation.log4j.appender.v2_17.OpenTelemetryAppender;</var>

@SpringBootApplication
public class Application {

  public static void main(String[] args) {
    // Configure OpenTelemetry as early as possible
    var openTelemetrySdk = openTelemetrySdk();

    <var>// Initialize Log4j2 appender</var>
    <var>OpenTelemetryAppender.setSdkLogEmitterProvider(openTelemetrySdk.getSdkLogEmitterProvider());</var>

    // Register runtime metrics instrumentation
    MemoryPools.registerObservers(openTelemetrySdk);
    GarbageCollector.registerObservers(openTelemetrySdk);

    SpringApplication.run(Application.class, args);
  }

```

## E. Configure a log emitter provider [#emitter-provider]

Continue in `Application.java` and add the following inside `openTelemetrySdk()`:

```
private static OpenTelemetrySdk openTelemetrySdk() {
. . .
    // Add otlp metric exporter
    var metricExporterBuilder =
        OtlpGrpcMetricExporter.builder()
            .setEndpoint("https://otlp.nr-data.net:4317")
            .setCompression("gzip")
            .addHeader("api-key", newrelicLicenseKey)
            // IMPORTANT: New Relic requires metrics to be delta temporality
            .setAggregationTemporalitySelector(AggregationTemporalitySelector.deltaPreferred())
            // Use exponential histogram aggregation for histogram instruments to produce better
            // data and compression
            .setDefaultAggregationSelector(
                DefaultAggregationSelector.getDefault()
                    .with(InstrumentType.HISTOGRAM, ExponentialHistogramAggregation.getDefault()));
    // Register and build a metric reader
    sdkMeterProviderBuilder.registerMetricReader(
                      PeriodicMetricReader.builder(metricExporterBuilder.build()).build());

    <var>// Configure log emitter provider</var>
    <var> var sdkLogEmitterProvider =</var>
        <var>SdkLogEmitterProvider.builder()</var>
            <var>// New Relic's max attribute length is 4095 characters</var>
            <var>.setLogLimits(</var>
                <var>() -> LogLimits.getDefault().toBuilder().setMaxAttributeValueLength(4095).build())</var>
            <var>.setResource(resource);</var>

    // Bring it all together
    return OpenTelemetrySdk.builder()
        .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
        .setTracerProvider(sdkTracerProviderBuilder.build())
        .setMeterProvider(sdkMeterProviderBuilder.build())
        .buildAndRegisterGlobal();
  }

```

Setting the log maximum attribute length prevents data from getting dropped if it exceeds the New Relic limit.

## F. Configure an OTLP log exporter [#otlp-exporter]

This is the component that exports your logs to New Relic. You are also adding a log processor in this step. 

Continue in `Application.java` and add the following:

```
private static OpenTelemetrySdk openTelemetrySdk() {
. . .
    // Configure log emitter provider
    var sdkLogEmitterProvider =
        SdkLogEmitterProvider.builder()
            // New Relic's max attribute length is 4095 characters
            .setLogLimits(
                () -> LogLimits.getDefault().toBuilder().setMaxAttributeValueLength(4095).build())
            .setResource(resource);
    <var>// Add otlp log exporter</var>
    <var>var logExporterBuilder =</var>
        <var>OtlpGrpcLogExporter.builder()</var>
            <var>.setEndpoint("https://otlp.nr-data.net:4317")</var>
            <var>.setCompression("gzip")</var>
            <var>.addHeader("api-key", newrelicLicenseKey);</var>
    <var>sdkLogEmitterProvider.addLogProcessor(</var>
              <var>BatchLogProcessor.builder(logExporterBuilder.build()).build());</var>

    // Bring it all together
    return OpenTelemetrySdk.builder()
        .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
        .setTracerProvider(sdkTracerProviderBuilder.build())
        .setMeterProvider(sdkMeterProviderBuilder.build())
        .buildAndRegisterGlobal();
  }

```
Notes:

* The endpoint you set here is where the generated data will be exported to; in this case, it is one of [New Relic’s OTLP endpoints](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-setup#review-settings). If your account is in the EU, use https://otlp.eu01.nr-data.net:4317.
* Setting `gzip` compression allows you to maximize the amount of data you can send per request; New Relic’s maximum allowed payload size is 1MB (10^6 bytes).
* The `api-key` header is how you configure which New Relic account you want your data exported to. You will export your license key as an environment variable when you complete the [step](#env-vars) below.

## G. Return the SDK [#return-sdk]

Continue in `Application.java` and add the following:

```
  private static OpenTelemetrySdk openTelemetrySdk() {
. . .
    <var>// Bring it all together
    <var>return OpenTelemetrySdk.builder()</var>
        <var>.setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))</var>
        <var>.setTracerProvider(sdkTracerProviderBuilder.build())</var>
        <var>.setMeterProvider(sdkMeterProviderBuilder.build())</var>
        <var>.setLogEmitterProvider(sdkLogEmitterProvider.build())</var>
        <var>.buildAndRegisterGlobal();</var>
  }

```

## H. Instrument the code: Add dependencies [#add-depend]


In this step, you'll be adding LOGGER from the `java.util.logging library`, which is not an OpenTelemetry component.

In `Contoller.java`, import the following dependencies, and then initialize a constant static for your logger under the previous constants:

```
<var>import org.apache.logging.log4j.LogManager;</var>
<var>import org.apache.logging.log4j.Logger;</var>

@RestController
public class Controller {
  // Tracing constants
  private static final Tracer TRACER = GlobalOpenTelemetry.getTracer(Controller.class.getName());
  private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
  private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");

  // Meter constants
  private static final Meter METER =
  GlobalOpenTelemetry.getMeterProvider().get(Application.class.getName());
  private final LongCounter MY_COUNTER =
  METER.counterBuilder("my-custom-counter").setDescription("A counter to count things").build();

  <var>// Logging constant (note that it is not an OTel component)</var>
  <var>private static final Logger LOGGER = LogManager.getLogger(Controller.class);</var>
. . .
}

```

## I. Add a sample log message [#add-log-message]

In `Contoller.java` add a logger and a sample message:

```
  private long fibonacci(long n) {
    var span = TRACER.spanBuilder("fibonacci").startSpan();
    span.setAttribute(ATTR_N, n);

    // A custom counter
    MY_COUNTER.add(123, Attributes.of(AttributeKey.stringKey("MyKey"), "SomeValue"));

    <var>// Add a custom log message</var>
    <var>LOGGER.info("A sample log message!");</var>
    try (var scope = span.makeCurrent()) {
. . .
span.setAttribute(ATTR_RESULT, last);
      return last;

    } <-- donn’t forget to add me in this step!
  }
```

## J. Create environment variables for your OTLP exporter [#env-vars]

Now, export the two environment variables you configured in your OTLP exporter. This method ensures your license key is not hardcoded. It also makes it simpler to update your OTLP endpoint.

Before you create the environment variables, keep the following in mind:

* Make sure to use your [ingest license key](https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/#license-key):
* By default, the OTLP exporter is pointed to one of [New Relic's OTLP endpoints](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-setup#review-settings). You can override it by setting a different value, for instance, if your account is based in the EU:
    * For US-based accounts: https://otlp.nr-data.net:4317
    * For EU-based accounts: https://otlp.eu01.nr-data.net:4317
* If you don't set the endpoint, the data will be exported to one of our OTLP endpoints by default, since you are setting it as the default in the code below.

Complete the following:

1. Add the following dependencies and code to `Application.java` so any environment variables you set can be picked up:

    ```
    <var>// Dependencies for resource configuration</var>
    <var>import java.util.Optional;</var>
    <var>import java.util.function.Function;</var>

    @SpringBootApplication
    public class Application {

      public static void main(String[] args) {
    . . .
      }

      private static OpenTelemetrySdk openTelemetrySdk() {
        <var>// Environment variables for your OTLP exporters</var>
        <var>var newrelicLicenseKey = getEnvOrDefault("NEW_RELIC_LICENSE_KEY", Function.identity(), "");</var>
        <var>var newrelicOtlpEndpoint = getEnvOrDefault("OTLP_HOST", Function.identity(), "https://otlp.nr-data.net:4317");</var>

        // Configure resource
    . . .
        // Bring it all together
        return OpenTelemetrySdk.builder()
            .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
            .setTracerProvider(sdkTracerProviderBuilder.build())
            .buildAndRegisterGlobal();
      }

      <var>private static <T> T getEnvOrDefault(</var>
          <var>String key, Function<String, T> transformer, T defaultValue) {</var>
        <var>return Optional.ofNullable(System.getenv(key))</var>
            <var>.filter(s -> !s.isBlank())</var>
            <var>.or(() -> Optional.ofNullable(System.getProperty(key)))</var>
            <var>.filter(s -> !s.isBlank())</var>
            <var>.map(transformer)</var>
            <var>.orElse(defaultValue);</var>
      <var>}</var>
    }
    ```

2. Run these commands in your terminal:

    ```
    export newrelicLicenseKey=<your_license_key>
    export newrelicOtlpEndpoint=https://otlp.nr-data.net:4317
    ```

## K. Exercise the app to generate some traffic [#exercise]

You're finally ready to send some data to New Relic!

1. To run the application, go to the `java` directory and execute this command:

    ```
    ./gradlew bootRun
    ```

    <Callout variant="tip">
      If your terminal displays the Spring ASCII, it means your app has successfully built and is running:
    </Callout>

2. To generate traffic, open a new terminal tab, navigate to the `java` directory, and run this command:

    ```
    ./load-generator.sh
    ```

## L. View your data in New Relic [#view-data]

You'll need to wait a few minutes for your trace data to show up in your New Relic account.

1. Go to **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > APM & services**.
2. Click your entity (service).

For more details about viewing your data, see [OpenTelemetry in the New Relic UI](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page)
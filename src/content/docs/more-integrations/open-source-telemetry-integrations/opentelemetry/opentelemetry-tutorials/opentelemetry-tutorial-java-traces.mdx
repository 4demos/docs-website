---
title: 'OpenTelemetry tutorial: Manual instrumentation of Java app with traces'
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: You can set up OpenTelemetry to monitor a simple Java app with traces.
---

To help you see how manual instrumentation works in a simple Java app, try out this tutorial that highlights traces. Traces allow you to see what happens when a user or an application makes a request in your service.

Each trace is made up of spans, which represent a logical unit of work or an operation within a particular request. You will learn how to create and end a span, set an attribute on a span, and record an exception, which is captured on the span as a span event.

<Callout variant="tip">
  If you have any questions about the status of traces in the OpenTelemetry project, see the [signal statuses](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases).
</Callout>

During this tutorial for generating and exporting traces, you'll open up the demo app and add dependencies, resources, a trace provider, exporter, and some instrumentation. Then, you'll run the app and check out the traces in the New Relic UI.

## A. Download the demo application [#download]

Start by cloning the demo application, which generates the nth number in the Fibonacci sequence:

```
git clone git@github.com:reese-lee/getting-started-guides.git
```
## B. Add OpenTelemetry Dependencies [#dependencies]

To add dependencies:

1. Go to the application's `java` directory.

    ```
    cd Uninstrumented/java
    ```
2. Open `build.gradle` in your preferred text editor.
3. Add the following in the `dependencies` block of the `build.gradle` file:
    ```
    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter-web'
        testImplementation 'org.springframework.boot:spring-boot-starter-test'

        <var>implementation platform('io.opentelemetry:opentelemetry-bom:1.18.0')</var>
        <var>implementation platform('io.opentelemetry:opentelemetry-bom-alpha:1.18.0-alpha')</var>
        <var>implementation platform('io.opentelemetry.instrumentation:opentelemetry-instrumentation-bom-alpha:1.18.0-alpha')</var>
        <var>implementation 'io.opentelemetry:opentelemetry-api'</var>
        <var>implementation 'io.opentelemetry:opentelemetry-sdk'</var>
        <var>implementation 'io.opentelemetry:opentelemetry-exporter-otlp'</var>
        <var>implementation 'io.opentelemetry.instrumentation:opentelemetry-spring-webmvc-5.3'</var>
    }
    ```

Notes:

* The `bom` (bill of materials) dependencies are used to synchronize versions of dependencies for a particular ecosystem. Since OpenTelemetry publishes a lot of Java components, these help ensure that all the versions are synchronized, whether you use just a few or a lot of them.
* The remaining dependencies provide access to the SDK, API, OTLP exporter, and instrumentation libraries.

## C. Configure a resource [#provide-resource]

A resource in OpenTelemetry represents information about an entity generating telemetry data. You'll learn how to associate all telemetry data you send to New Relic with a resource so it can be linked with the appropriate entity in New Relic.

1. Go to the app's source code directory:
    ```
    cd src/main/java/com/example/demo
    ```
2. Open `Application.java`.
3. Configure an instance of the OpenTelemetry SDK as early as possible, so add the following to the main function block:
    ```
    @SpringBootApplication
    public class Application {

      public static void main(String[] args) {
        <var>// Configure OpenTelemetry as early as possible</var>
        <var>var openTelemetrySdk = openTelemetrySdk();</var>

        SpringApplication.run(Application.class, args);
      }
    }
    ```
4. Import the necessary dependencies and add the following code directly under the `main` function block:
    ```
    // Dependencies for resource configuration</var>
    <var>import io.opentelemetry.api.GlobalOpenTelemetry;</var>
    <var>import io.opentelemetry.sdk.OpenTelemetrySdk;</var>
    <var>import io.opentelemetry.sdk.resources.Resource;</var>
    <var>import io.opentelemetry.semconv.resource.attributes.ResourceAttributes;</var>
    <var>import java.util.UUID;</var>

    @SpringBootApplication
    public class Application {

      public static void main(String[] args) {
    . . .
    }

      <var>private static OpenTelemetrySdk openTelemetrySdk() {</var>
          <var>// Configure resource</var>
          <var>var resource =</var>
              <var>Resource.getDefault().toBuilder()</var>
                <var>.put(ResourceAttributes.SERVICE_NAME, "getting-started-java")</var>
                <var>.put(ResourceAttributes.SERVICE_INSTANCE_ID, UUID.randomUUID().toString())</var>
                <var>.build();</var>
      <var>}</var>
    . . .
    }
    ```

Notes:

* `SERVICE_NAME` defines your app name and will be how you identify your service in New Relic. This value is also how you associate all the telemetry data generated by this app with an entity in New Relic, and allows you to scope your queries to a specific entity.
* `SERVICE_INSTANCE_ID` is required to light up certain New Relic features; it will allow you to differentiate between hosts.

## D. Configure a tracer provider [#trace-provider]

The tracer provider will create a [Tracer](https://opentelemetry.io/docs/concepts/signals/traces/#tracer), which creates spans that contain more information about a given operation, such as a service request. You will instantiate the tracer later when you complete the [instrumentation steps](#initial-instrum).

Continue in `Application.java` and add the following:

```
<var>// Dependencies for tracing</var>
<var>import io.opentelemetry.sdk.trace.SdkTracerProvider;</var>
<var>import io.opentelemetry.sdk.trace.SpanLimits;</var>
<var>import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;</var>
<var>import io.opentelemetry.exporter.otlp.trace.OtlpGrpcSpanExporter;</var>
<var>import io.opentelemetry.api.common.Attributes;</var>
<var>import io.opentelemetry.context.propagation.ContextPropagators;</var>

@SpringBootApplication
public class Application {

  public static void main(String[] args) {
    // Configure OpenTelemetry as early as possible
    var openTelemetrySdk = openTelemetrySdk();

    SpringApplication.run(Application.class, args);
  }

  private static OpenTelemetrySdk openTelemetrySdk() {
    // Configure resource
. . .
    <var>// Configure tracer provider</var>
    <var>var sdkTracerProviderBuilder =</var>
        <var>SdkTracerProvider.builder()</var>
            <var>.setResource(resource)</var>
            <var>// New Relic's max attribute length is 4095 characters</var>
            <var>.setSpanLimits(</var>
                <var>SpanLimits.getDefault().toBuilder().setMaxAttributeValueLength(4095).build());</var>

}
```

Notes:

Setting a limit on the maximum attribute value length will prevent span data from getting dropped if it exceeds [New Relic's limit](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-attributes/).

## E. Configure an OTLP span exporter

This is the component that sends spans from your application to New Relic.

Continue in `Application.java` and add this directly under the tracer provider:

```
  private static OpenTelemetrySdk openTelemetrySdk() {
    // Configure resource
    var resource =
        Resource.getDefault().toBuilder()
          .put(ResourceAttributes.SERVICE_NAME, "getting-started-java")
          .put(ResourceAttributes.SERVICE_INSTANCE_ID, UUID.randomUUID().toString())
          .build();

    // Configure tracer provider
    var sdkTracerProviderBuilder =
        SdkTracerProvider.builder()
            .setResource(resource)
            // New Relic's max attribute length is 4095 characters
            .setSpanLimits(
                SpanLimits.getDefault().toBuilder().setMaxAttributeValueLength(4095).build());

    <var>// Add otlp span exporter</var>
    <var>var spanExporterBuilder =</var>
    <var>OtlpGrpcSpanExporter.builder()</var>
      <var>.setEndpoint(newrelicOtlpEndpoint)</var>
      <var>.setCompression("gzip")</var>
      <var>.addHeader("api-key", newrelicLicenseKey);</var>
    <var>sdkTracerProviderBuilder.addSpanProcessor(</var>
      <var>BatchSpanProcessor.builder(spanExporterBuilder.build()).build());</var>

  }
```

Notes:

* You will set both of the following environment variables when you complete the [steps](#env-vars) below:
    * The `newrelicOtlpEndpoint` env var is how you configure where the generated data will be exported to.
    * The `newrelicLicenseKey` env var is how you configure which New Relic account you want your data exported to.
* Setting `gzip` compression allows you to maximize the amount of data you can send per request; New Relic's maximum allowed payload size is 1MB (10^6 bytes).

## Return the SDK [#return-sdk]

Bring it all together by returning the SDK.

<Callout variant="tip">
  As an alternative to the SDK steps here, you can use the [SDK autoconfigure extension module](https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions/autoconfigure) to configure the SDK; see [SDK auto config](#SDK-auto-config) for instructions. This extension only impacts the SDK configuration; you still need to follow the [instrumentation steps](#initial-instrum].
</Callout>

In `Application.java`, add the following code under your span exporter builder:

```
  private static OpenTelemetrySdk openTelemetrySdk() {
    // Configure resource
. . .
    // Configure tracer provider
    var sdkTracerProviderBuilder =
        SdkTracerProvider.builder()
            .setResource(resource)
            // New Relic's max attribute length is 4095 characters
            .setSpanLimits(
                SpanLimits.getDefault().toBuilder().setMaxAttributeValueLength(4095).build());

   // Add otlp span exporter
    var spanExporterBuilder =
        OtlpGrpcSpanExporter.builder()
            .setEndpoint(newrelicOtlpEndpoint)
            .setCompression("gzip")
            .addHeader("api-key", newrelicLicenseKey);
    sdkTracerProviderBuilder.addSpanProcessor(
        BatchSpanProcessor.builder(spanExporterBuilder.build()).build());

    <var>// Bring it all together</var>
    <var>return OpenTelemetrySdk.builder()</var>
        <var>.setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))</var>
        <var>.setTracerProvider(sdkTracerProviderBuilder.build())</var>
        <var>.buildAndRegisterGlobal();</var>
  }
```

## F. Create environment variables for your OTLP exporter [#env-vars]

Now, export the two environment variables you configured in your OTLP exporter. This method ensures your license key is not hardcoded. It also makes it simpler to update your OTLP endpoint.

Before you create the environment variables, keep the following in mind:

* Make sure to use your [ingest license key](https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/#license-key):
* By default, the OTLP exporter is pointed to one of [New Relic's OTLP endpoints](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-setup#review-settings). You can override it by setting a different value, for instance, if your account is based in the EU:
    * For US-based accounts: https://otlp.nr-data.net:4317
    * For EU-based accounts: https://otlp.eu01.nr-data.net:4317
* If you don't set the endpoint, the data will be exported to one of our OTLP endpoints by default, since you are setting it as the default in the code below.

Complete the following:

1. Add the following dependencies and code to `Application.java` so any environment variables you set can be picked up:

    ```
    <var>// Dependencies for resource configuration</var>
    <var>import java.util.Optional;</var>
    <var>import java.util.function.Function;</var>

    @SpringBootApplication
    public class Application {

      public static void main(String[] args) {
    . . .
      }

      private static OpenTelemetrySdk openTelemetrySdk() {
        <var>// Environment variables for your OTLP exporters</var>
        <var>var newrelicLicenseKey = getEnvOrDefault("NEW_RELIC_LICENSE_KEY", Function.identity(), "");</var>
        <var>var newrelicOtlpEndpoint = getEnvOrDefault("OTLP_HOST", Function.identity(), "https://otlp.nr-data.net:4317");</var>

        // Configure resource
    . . .
        // Bring it all together
        return OpenTelemetrySdk.builder()
            .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
            .setTracerProvider(sdkTracerProviderBuilder.build())
            .buildAndRegisterGlobal();
      }

      <var>private static <T> T getEnvOrDefault(</var>
          <var>String key, Function<String, T> transformer, T defaultValue) {</var>
        <var>return Optional.ofNullable(System.getenv(key))</var>
            <var>.filter(s -> !s.isBlank())</var>
            <var>.or(() -> Optional.ofNullable(System.getProperty(key)))</var>
            <var>.filter(s -> !s.isBlank())</var>
            <var>.map(transformer)</var>
            <var>.orElse(defaultValue);</var>
      <var>}</var>
    }
    ```

2. Run these commands in your terminal:

    ```
    export newrelicLicenseKey=<your_license_key>
    export newrelicOtlpEndpoint=https://otlp.nr-data.net:4317
    ```

## G. Instrument the code: Provide automatic base instrumentation [#initial-instrum]

At this point, you have successfully configured your OpenTelemetry resource for tracing. Now you can instrument the application code.

Here are the steps:

1. In  `Application.java`, add the following code to provide automatic base instrumentation for Spring web applications:

    ```
    // Dependencies for tracing
    <var>import io.opentelemetry.instrumentation.spring.webmvc.v5_3.SpringWebMvcTelemetry;</var>
    . . .

    @SpringBootApplication
    public class Application {

      public static void main(String[] args) {
        // Configure OpenTelemetry as early as possible
        var openTelemetrySdk = openTelemetrySdk();

        SpringApplication.run(Application.class, args);
      }

      private static OpenTelemetrySdk openTelemetrySdk() {
    . . .
      }

      private static <T> T getEnvOrDefault(
    . . .
      }

      <var>// Add Spring WebMVC instrumentation by registering a tracing filter</var>
      <var>@Bean</var>
      <var>public Filter webMvcTracingFilter() {</var>
        <var>return SpringWebMvcTelemetry.create(GlobalOpenTelemetry.get()).createServletFilter();</var>
      <var>}</var>
    }
    ```

2. Complete instrumentation by going to `Controller.java` and adding the following code:

    ```
    <var>mport io.opentelemetry.api.GlobalOpenTelemetry;</var>

    <var>// Dependencies for tracing</var>
    <var>import io.opentelemetry.api.trace.Tracer;</var>
    <var>import io.opentelemetry.api.trace.StatusCode;</var>
    <var>import io.opentelemetry.api.trace.Span;</var>
    <var>import io.opentelemetry.api.common.Attributes;</var>
    <var>import io.opentelemetry.api.common.AttributeKey;</var>

    @RestController
    public class Controller {

      <var>private static final Tracer TRACER = GlobalOpenTelemetry.getTracer(Controller.class.getName());</var>
      <var>private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");</var>
      <var>private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");</var>

      @GetMapping(value = "/fibonacci")
      public Map<String, Object> ping(@RequestParam(required = true, name = "n") long n) {
        return Map.of("n", n, "result", fibonacci(n));
      }
    . . .
    }
    ```
    <Callout variant="tip">
      The [Tracer](https://opentelemetry.io/docs/concepts/signals/traces/#tracer) creates spans, and the static constants are set to hold two attribute keys, which you will use later to provide request-level insights in your spans. 
    </Callout>

## H. Instrument the code: Set a span attribute [#set-span-attrib]

You have the freedom to create whatever spans you want, and it is up to you to annotate your spans with attributes on specific operations. The attributes you set provide additional context about the specific operation you are tracking, such as results or operation properties.

1. In your `Controller.java`, locate `fibonacci()` and add the following code to start a new span and set your first attribute:

    ```
      private long fibonacci(long n) {
        <var>// Start a new span and set your first attribute</var>
        <var>var span = TRACER.spanBuilder("fibonacci").startSpan();</var>
        <var>span.setAttribute(ATTR_N, n);</var>

        try {
    . . .
        }
      }
    ```
    <Callout variant="tip">
      This creates a span called `fibonacci` that captures data about the execution of this method, starting with an attribute that stores the value of n from the user's request.
    </Callout>

2. To obtain additional granularity into your code, add these attributes to your span to store information about successful requests:

    ```
    private long fibonacci(long n) {
      // Start a new span and set your first attribute
      var span = TRACER.spanBuilder("fibonacci").startSpan();
      span.setAttribute(ATTR_N, n);
      try {
        if (n < 1 || n > 90) {
          throw new IllegalArgumentException("n must be 1 <= n <= 90.");
        }

        // Base cases
        if (n == 1) {
          <var>span.setAttribute(ATTR_RESULT, 1);</var>
          return 1;
        }
        if (n == 2) {
          <var>span.setAttribute(ATTR_RESULT, 1);</var>
          return 1;
        }

        long lastLast = 1;
        long last = 2;
        for (long i = 4; i <= n; i++) {
          long cur = last + lastLast;
          lastLast = last;
          last = cur;
        }
        <var>span.setAttribute(ATTR_RESULT, last);</var>
        return last;
      } catch (IllegalArgumentException e) {
        throw e;
      } finally {
      }
    }
    ```

## I. Instrument the code: Record an exception

You may want to record exceptions as they happen, so we recommend you do this in conjunction with setting the span status.

1. Set your span as the current span, then set the status code to error in the event of an exception, and end the span:

    ```
      private long fibonacci(long n) {
        // Start a new span and set your first attribute
        var span = TRACER.spanBuilder("fibonacci").startSpan();
        span.setAttribute(ATTR_N, n);

        <var>// Set the span as the current span</var>
        <var>try (var scope = span.makeCurrent()) {</var>
          if (n < 1 || n > 90) {
            throw new IllegalArgumentException("n must be 1 <= n <= 90.");
          }

          // Base cases
          if (n == 1) {
            span.setAttribute(ATTR_RESULT, 1);
            return 1;
          }
          if (n == 2) {
            span.setAttribute(ATTR_RESULT, 1);
            return 1;
          }

          long lastLast = 1;
          long last = 2;
          for (long i = 4; i <= n; i++) {
            long cur = last + lastLast;
            lastLast = last;
            last = cur;
          }
          span.setAttribute(ATTR_RESULT, last);
          return last;
        } catch (IllegalArgumentException e) {
            <var>// Record the exception and set the span status</var>
            <var>span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());</var>
          throw e;
        } finally {
            <var>// End the span</var>
            <var>span.end();</var>
        }
      }
    ```
    <Callout variant="tip">
      This method throws an `IllegalArgumentException` if a user provides invalid input; when this happens, the exception is recorded as an event on the span and the span's status will be set to `ERROR`. The exception message is captured as the status description. Before moving to the next step, end the span.
    </Callout>

2. In `handleException()` in the `ErrorHandler` class, set the status for the span to `ERROR`:

    ```
    @ControllerAdvice
    private static class ErrorHandler {

      @ExceptionHandler({
              IllegalArgumentException.class,
              MissingServletRequestParameterException.class,
              HttpRequestMethodNotSupportedException.class
      })
      public ResponseEntity<Object> handleException(Exception e) {
        <var>// Set the span status and description</var>
        <var>Span.current().setStatus(StatusCode.ERROR, e.getMessage());</var>

        return new ResponseEntity<>(Map.of("message", e.getMessage()), HttpStatus.BAD_REQUEST);
      }

    }
    ```

Just like before, this sets the span's status code if the user inputs an invalid number. However, because this happens in the exception handler, rather than in `fibonacci()`, the current span is the parent span for the request. Now, when your application endpoint raises an exception, both the parent span and child span will have a span status of `ERROR`.

## J. Exercise the app to generate some traffic [#exercise]

You're finally ready to send some data to New Relic!

1. To run the application, go to the `java` directory and execute this command:

    ```
    ./gradlew bootRun
    ```

    <Callout variant="tip">
      If your terminal displays the Spring ASCII, it means your app has successfully built and is running:
    </Callout>

2. To generate traffic, open a new terminal tab, navigate to the `java` directory, and run this command:

    ```
    ./load-generator.sh
    ```

## K. View your data in New Relic [#view-data]

You'll need to wait a few minutes for your trace data to show up in your New Relic account.

1. Go to **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > APM & services**.
2. Click your entity (service).
3. In the left pane's **Monitor** section, click **Distributed tracing**.
4. For details, click on an individual trace. If **Group similar traces** is on in the top menu, click on a trace group, and then click on an individual trace.
5. If you don't see the traces you want, you can filter by the `trace.id`.

For more details about viewing your data, see [OpenTelemetry in the New Relic UI](https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page)
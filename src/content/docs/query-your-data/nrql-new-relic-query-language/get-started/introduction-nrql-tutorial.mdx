---
title: "Introductory NRQL tutorial: unlock your data"
tags:
  - NRQL tutorial
  - 'NRQL: New Relic query language'
  - Get started
  - Tutorial
translate:
  - jp
  - kr
metaDescription: "Learn how to use NRQL with this basic, introductory tutorial."
redirects:
---

import queriesnrqltutorial1 from 'images/queries-nrql_screenshot-crop-tutorial-1.png'

import queriesnrqltutorial2 from 'images/queries-nrql_screenshot-crop-tutorial-2.png'

import queriesnrqltutorial3 from 'images/queries-nrql_screenshot-crop-tutorial-3.png'

import queriesnrqltutorial4 from 'images/queries-nrql_screenshot-crop-tutorial-4.png'

import queriesnrqltutorial5 from 'images/queries-nrql_screenshot-crop-tutorial-5.png'

import queriesnrqltutorial6 from 'images/queries-nrql_screenshot-crop-tutorial-6.png'

import queriesnrqltutorial7 from 'images/queries-nrql_screenshot-crop-tutorial-7.png'

import queriesnrqltutorial8 from 'images/queries-nrql_screenshot-crop-tutorial-8.png'

import queriesnrqltutorial9 from 'images/queries-nrql_screenshot-crop-tutorial-9.png'

import queriesnrqltutorial10 from 'images/queries-nrql_screenshot-crop-tutorial-10.png'

import queriesnrqltutorial11 from 'images/queries-nrql_screenshot-crop-tutorial-11.png'

import queriesnrqltutorial12 from 'images/queries-nrql_screenshot-crop-tutorial-12.png'

import queriesnrqltutorial13 from 'images/queries-nrql_screenshot-crop-tutorial-13.png'

import queriesnrqltutorial14 from 'images/queries-nrql_screenshot-crop-tutorial-14.png'

import queriesnrqltutorial15 from 'images/queries-nrql_screenshot-crop-tutorial-15.png'

import queriesnrqltutorial16 from 'images/queries-nrql_screenshot-crop-tutorial-16.png'

import queriesnrqltutorial17 from 'images/queries-nrql_screenshot-crop-tutorial-17.png'

import queriesnrqltutorial18 from 'images/queries-nrql_screenshot-crop-tutorial-18.png'

import queriesnrqltutorial19 from 'images/queries-nrql_screenshot-crop-tutorial-19.png'

import queriesnrqltutorial20 from 'images/queries-nrql_screenshot-crop-tutorial-20.png'

We've covered the basics of NRQL in our other topics, such as [what NRQL is](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/), [how NRQL works](docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-how-nrql-works/), and [how NRQL relates to charts and dashboards](docs/query-your-data/nrql-new-relic-query-language/get-started/charts-and-dashboards-with-nrql/). With this information, beginning to work with NRQL is the next step, and this tutorial is designed to help you do just that! Below we'll cover some foundational concepts within the language and get you set up with creating a some basic NRQL queries using your data. This tutorial teaches you how to:

* Use `SELECT` and `FROM`
* Use `LIMIT`
* Specify attributes
* Aggregate using `average()`, `max()`, `min()`, `sum()`, and `count()`
* Use `SINCE` and `UNTIL`
* Plot line graphs with `TIMESERIES`
* Filter using `WHERE`
* Group attributes using `FACET`

Want to learn NRQL within the New Relic platform? We've included a NRQL Lessons application on our [opensource.newrelic.com](https://opensource.newrelic.com/projects/newrelic/nr1-learn-nrql) site to help you quickly see NRQL's value and power within the application. The video below shows you how to install the NRQL Lesson.

<Video
  id="3UHEHbprs6I"
  type="youtube"
/>

Ready to get started? Let's go!

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="first-query"
    title="1. Your First Query"
  >
  <SideBySide>
  <Side>
Let's start by looking at a single event type in NRDB called **Transaction**, gathered by New Relic APM. Every NRQL query must have `SELECT` and `FROM` clauses: you must `SELECT` some data and tell us where it's `FROM`. Start with this basic query that selects everything from the **Transaction** event type.
 
    ```sql
    SELECT *
    FROM Transaction
    ```

  </Side>
  <Side>
    <img
  title="Select and From query"
  alt="A screenshot of a query with Select and From"
  src={queriesnrqltutorial1}
/>
  </Side>
  </SideBySide>
  <SideBySide>
  <Side>
 This returns a lot of results, each with a timestamp and a collection of attributes. For now, we only want a single result, so let's limit the results to a single record using `LIMIT 1`.

 <Callout variant="important"> When a LIMIT isn't supplied the default will be used, which is 100 table rows for SELECT * queries or 10 aggregated values for FACET queries and SELECT (attributes) queries. You can specify any limit up to the maximum. Use LIMIT MAX to return the maximum number of results possible.
</Callout>

    ```sql
    SELECT *
    FROM Transaction
    LIMIT 1
    ```
  </Side>
  <Side>
 <img
  title="Select, From, and Limit query"
  alt="A screenshot of a query with Select, From, and Limit"
  src={queriesnrqltutorial2}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    We're now controlling the volume of the results. But what if we don't want all the attributes? What if we would prefer to see only specific data points? Like SQL, we can do this with only a few characters by replacing * with the name of the attribute(s) we want. In this case, we'll ask for the name of a transaction and the duration of time it took.

    ```sql
    SELECT name, duration
    FROM Transaction
    ```
    
  </Side>
  <Side>
  <img
  title="Select and From with Duration query"
  alt="A screenshot of a query with Select and From using Duration"
  src={queriesnrqltutorial3}
/>
  </Side>
</SideBySide>
With this, you've completed queries that can return either all or some specific attributes of an event, as well as querying a specific number of events. Let's go to the next step: aggregating data.
  </Collapser>
  <Collapser
    className="freq-link"
    id="aggregate-data"
    title="2. Aggregate Data"
  >
<SideBySide>
  <Side>
Sometimes you may want to view summarized aggregate data across many events instead of viewing individual events. This is where NRDB shines. NRDB can scan billions of events and provide instant, real-time answers to questions about your data. For example, each `Transaction` event has a duration attribute that represents how many seconds the call took to execute. Let's see if we can discover the average duration across all `Transaction` events:
```sql
SELECT average(duration) 
FROM Transaction
```
  </Side>
  <Side>
    <img
  title="Select average duration from transaction query"
  alt="A screenshot of a query selecting the average duration from transaction"
  src={queriesnrqltutorial4}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
NRQL has many built-in functions you can use to aggregate event data. Common functions you might use include `max()`, `min()`, `median()`, and `percentile()`. In the following query, we'll ask NRDB for the duration of the slowest transaction from the last 60 minutes To do this, we will ask NRDB for the `max(duration).`
```sql
SELECT max(duration) 
FROM Transaction
```
  </Side>
  <Side>
    <img
  title="Select maximum duration from transaction query"
  alt="A screenshot of a query selecting the maximum duration from transaction"
  src={queriesnrqltutorial5}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
We now know how long the slowest customer experience in the last 60 minutes took. Next, let's find the inverse and see how long the fastest experience was by asking NRDB for the `min(duration)`.
```sql
SELECT min(duration) 
FROM Transaction
```
  </Side>
  <Side>
    <img
  title="Select minimum duration from transaction query"
  alt="A screenshot of a query selecting the minimum duration from transaction"
  src={queriesnrqltutorial6}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
As you can see, `max()` and `min()` both return important data points. However, we may also want to perform arithmetic on our data. With 'sum()', we can do basic addition on a numeric attribute. In this query, we'll use a new attribute, `databaseCallCount`. This attribute counts the number of database calls each transaction makes. By adding them, we can get the total volume of database calls in the default 60 minute time window (this will be 0 if your apps don't talk to a database).
```sql
SELECT sum(databaseCallCount) 
FROM Transaction
```
  </Side>
  <Side>
    <img
  title="Select sum of the databaseCallCount from transaction query"
  alt="A screenshot of a query selecting the sum of the databaseCallCount from transaction"
  src={queriesnrqltutorial7}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
Finally, you can also count all recorded Transaction events. We do this with `count(*)`. In this example, we count all recorded events for all applications reporting to New Relic APM:
```sql
SELECT count(*) 
FROM Transaction
```
  </Side>
  <Side>
    <img
  title="Select all recorded transactions query"
  alt="A screenshot of a query selecting all recorded transactions"
  src={queriesnrqltutorial8}
/>
  </Side>
</SideBySide>
Now we're beginning to find out a lot about our data. We're measuring the boundaries of our performance, grouping event data together, and even calculating information about our chosen attribute. We've chosen duration and calculated the `average`, `max`, and `min`, added up numeric attributes, and counted all the events for a time period. Manipulating data like this will help us when we want to present data in visualizations, which assists us in spotting performance issues. Let's go to the next step: using time ranges.
  </Collapser>
  <Collapser
    className="freq-link"
    id="time-ranges"
    title="3. Use Time Ranges"
  >
<SideBySide>
  <Side>
    Every piece of data in NRDB has a `timestamp`, and every query operates on a subset of data within a time range. If you don't provide a time range in your NRQL query, it will return the last 60 minutes by default as we saw in the previous lesson. But what if we want to see data from a different time range? How do we control the window of data we see? The answer to these questions is very straightforward: use `SINCE` and `UNTIL` keywords to provide a beginning and end to your query's time range.
```sql 
SELECT average(duration) 
FROM Transaction 
SINCE 1 day ago
```
  </Side>
  <Side>
    <img
  title="Select the average duration since 1 day ago query"
  alt="A screenshot of a query selecting the average duration since 1 day ago"
  src={queriesnrqltutorial9}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    We can also specify time ranges relative to when we make our queries by using keywords like `day`, `week`, `hour`, `minute`, or their plural equivalents. We can also use logical expressions like `SINCE` today or `SINCE` this week.
```sql
SELECT average(duration) 
FROM Transaction 
SINCE this week
```
  </Side>
  <Side>
    <img
  title="Select the average duration since 1 week ago"
  alt="A screenshot of a query selecting the average duration since 1 week ago"
  src={queriesnrqltutorial10}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    Here is another query that demonstrate relative time ranges. Note that when specifying a relative time, you need to include the keyword `ago`.
```sql
SELECT average(duration) 
FROM Transaction 
SINCE 1 week ago 
UNTIL 2 days ago
```
  </Side>
  <Side>
    <img
  title="Select the average duration since 1 week ago until 2 days ago"
  alt="A screenshot of a query selecting the average duration since 1 week ago until 2 days ago"
  src={queriesnrqltutorial11}
/>
  </Side>
</SideBySide>
Now we're getting even more control of our data. By adding a time frame to a query, we're define exactly which window of data we want to see. These controls let us zero in on the data we want by defining where the data reporting should start and end. In our examples, we saw that we can easily choose the window and use common terms like `week`, `day`, `hour`, `minute`, and their plurals. You can even use `month` and `year` if you're storing that much data in New Relic. Let's go to the next step: querying a time series.
  </Collapser>
  <Collapser
    className="freq-link"
    id="time-series"
    title="4. Query time series"
  >
<SideBySide>
  <Side>
    A common NRQL use case is querying how values change over time. This type of query provides data for line charts, area charts, and other visualizations. These "Timeseries" queries in NRDB are easy to do! We've already run some queries to explore aggregation functions `average()`, `max()`, `min()`, `sum()`, and `count()`. Now, we can take any query made with aggregation functions and add the `TIMESERIES` keyword to plot the values over time.
```sql
SELECT average(duration) 
FROM Transaction 
SINCE 1 day ago 
TIMESERIES
```
  </Side>
  <Side>
    <img
  title="Select the average duration since 1 day ago over with a timeseries"
  alt="A screenshot of a query that selects the average duration since 1 day ago with a timeseries"
  src={queriesnrqltutorial12}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    A "Timeseries" query breaks the data into a number of regions called buckets over the specified time period. You can have NRDB pick a default value for the width of that bucket, or you can specify your own. Let's ask NRDB to show us the average duration of application transactions, with returned data organized into 1-hour buckets.
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    SINCE 1 day ago 
    TIMESERIES 1 hour
    ```
  </Side>
  <Side>
    <img
  title="Select the average duration since 1 day ago using 1 hour buckets"
  alt="A screenshot of a query selecting the average duration since 1 day ago using 1 hour buckets"
  src={queriesnrqltutorial13}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    Notice this may return a flatter graph, since we only have 24 data points across the 1-day period being plotted. But what if you want to see the maximum possible granularity? Any timeseries query can have up to 366 data buckets, meaning the maximum granularity possible for 24 hours is to bucket our data into 4 minute windows. We could see this by using `TIMESERIES 4 minutes`, or we could ask NRDB to calculate this for us using `TIMESERIES MAX`:
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    SINCE 1 day ago 
    TIMESERIES MAX
    ```
  </Side>
  <Side>
    <img
  title="Select the average duration since 1 day ago using the maximum number of buckets"
  alt="A screenshot of a query selecting the average duration since 1 ago using the maximum number of buckets"
  src={queriesnrqltutorial14}
/>
  </Side>
</SideBySide>
Now we're achieving new levels of visualization, breaking out from summarized numbers to line charts of data trends over time. As you can see, using `TIMESERIES` offers full control over visualizations, granularity, and averaging data over specified windows. Let's go to the next step: using the 'Where' clause.
  </Collapser>
  <Collapser
    className="freq-link"
    id="where"
    title="5. Use Where clauses"
  >
<SideBySide>
  <Side>
    You may find that sometimes, you want your query to operate on a specific subset of NRDB data. For example, let's query our backend application's average response time. This data includes an attribute called `transactionType`, which specifies whether the transaction we timed was a "Web" or "Non-Web" (such as a cron job or queued task) transaction. Let's filter our query to only return data for the "Web" transactionType:
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    WHERE transactionType='Web' 
    TIMESERIES
    ```
  </Side>
  <Side>
    <img
  title="Select the avarege duration for Web transaction types with a timeseries"
  alt="A screenshot of a query selecting the average duration for Web transaction types with a timeseries"
  src={queriesnrqltutorial15}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    You can also combine `AND` and `OR` to make more complex queries, using parentheses "(" and ")" to control how these work together.This query shows the average response time of "Web" transactions that were both faster than 100ms, and had a response code of either 200 or 302. Notice how we use parentheses to control the `OR`, which may behave differently than you'd expect.
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    WHERE transactionType='Web' 
    AND duration < 0.1 
    AND (httpResponseCode=200 
    OR httpResponseCode=302) 
    TIMESERIES
    ```
  </Side>
  <Side>
    <img
  title="Select the average duration for Web transaction types with a duration of less than 0.1 seconds with the response codes 200 or 302 with a timeseries"
  alt="A screenshot of a query selecting the average duration for Web transaction types with a duration of less than 0.1 seconds with the response codes 200 or 302 with a timeseries"
  src={queriesnrqltutorial16}
/>
  </Side>
</SideBySide>
So far, every query we've made has performed actions on all available data in the given time window. But filtering out undesired data is also important. The examples above are useful when we want to filter to a type of transaction, or when a response code is a specific value. Similarly, you could filter to a specific `appName`, Transaction `name` or even a custom attribute you've tagged on your data. Let's go to the final step in the tutorial: using faceted queries.
  </Collapser>
  <Collapser
    className="freq-link"
    id="facet"
    title="6. Use faceted queries"
  >
<SideBySide>
  <Side>
    Often, you'll want to determine the "Top N" values grouped by a specific attribute. In NRQL, you do this using `FACET`. For example, here we query for the slowest `Transaction` calls observed on average, grouped by name. We could think of this as "faceted by name".
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    FACET name 
    SINCE 1 day ago
    ```
  </Side>
  <Side>
    <img
  title="Select the average duration since 1 day ago faceted by name"
  alt="A screenshot of a query that selects the average duration since 1 day ago faceted by name"
  src={queriesnrqltutorial17}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    By default, a faceted query will return the top 10 results, but you can customize how many results are returned with by placing a  `LIMIT`. In this example, we will retrieve the top 5 results displayed on a line chart with `TIMESERIES`.
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    FACET name 
    SINCE 3 hours ago 
    LIMIT 5 
    TIMESERIES
    ```
  </Side>
  <Side>
    <img
  title="Select the average duration from the top 5 results since 3 hours ago grouped by name with a timeseries"
  alt="A screenshot of a query selecting the average duration from the top 4 results since 3 hours ago grouped by name with a timeseries"
  src={queriesnrqltutorial18}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    But maybe you don't want a line chart or want a larger list of transactions. By removing the `TIMESERIES`, we can instead render a bar or pie chart, and by increasing the `LIMIT`, we can increase the scope of the list.
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    FACET name 
    SINCE 3 hours ago 
    LIMIT 20
    ```
  </Side>
  <Side>
    <img
  title="Select the average duration from the top 20 results since 3 hours ago grouped by name without a timeseries"
  alt="A screenshot of a query selecting the average duration from the top 20 results since 3 hours ago grouped by name without a timeseries"
  src={queriesnrqltutorial19}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
  Finally, here's a slightly more complex query that compares the quantity of Web transactions, broken down by individual applications that report to New Relic:
  ```sql
  SELECT count(*) 
  FROM Transaction 
  WHERE transactionType='Web' 
  FACET appName 
  LIMIT 5 
  SINCE 6 hours ago 
  TIMESERIES
  ```
  </Side>
  <Side>
    <img
  title="Select all web transactions from the top 5 results since 6 hours ago grouped by appName with a timeseries"
  alt="A screenshot of a query selecting all web transactions from the top 5 results since 6 hours ago grouped by appName with a timeseries"
  src={queriesnrqltutorial20}
/>
  </Side>
</SideBySide>
Grouping or "faceting" is important: it allows us to get dimensional with our data. Using the `FACET` keyword is the simplest way to do this. When applying an aggregation function, we can use `FACET` to group by any attribute, default or custom, that reports event data (just like the `WHERE` clause). We recommend tagging on custom data to your events. This allows you to more easily investigate the resulting data set.
  </Collapser>
</CollapserGroup>

Congratulations: you've completed the first NRQL tutorial! If you've made it this far, you now know the basics of querying event data using NRQL. You can create dashboards and alerts and, if you know some React, you can even create your own Apps to run natively inside New Relic One.
---
title: "Introductory NRQL tutorial: unlock your data"
tags:
  - NRQL tutorial
  - 'NRQL: New Relic query language'
  - Get started
  - Tutorial
translate:
  - jp
  - kr
metaDescription: "Learn how to use NRQL with this basic, introductory tutorial."
redirects:
---

import queriesnrqltutorial1 from 'images/queries-nrql_screenshot-crop-tutorial-1.png'

import queriesnrqltutorial2 from 'images/queries-nrql_screenshot-crop-tutorial-2.png'

import queriesnrqltutorial3 from 'images/queries-nrql_screenshot-crop-tutorial-3.png'

import queriesnrqltutorial4 from 'images/queries-nrql_screenshot-crop-tutorial-4.png'

import queriesnrqltutorial5 from 'images/queries-nrql_screenshot-crop-tutorial-5.png'

import queriesnrqltutorial6 from 'images/queries-nrql_screenshot-crop-tutorial-6.png'

import queriesnrqltutorial7 from 'images/queries-nrql_screenshot-crop-tutorial-7.png'

import queriesnrqltutorial8 from 'images/queries-nrql_screenshot-crop-tutorial-8.png'

import queriesnrqltutorial9 from 'images/queries-nrql_screenshot-crop-tutorial-9.png'

import queriesnrqltutorial10 from 'images/queries-nrql_screenshot-crop-tutorial-10.png'

import queriesnrqltutorial11 from 'images/queries-nrql_screenshot-crop-tutorial-11.png'

import queriesnrqltutorial12 from 'images/queries-nrql_screenshot-crop-tutorial-12.png'

import queriesnrqltutorial13 from 'images/queries-nrql_screenshot-crop-tutorial-13.png'

import queriesnrqltutorial14 from 'images/queries-nrql_screenshot-crop-tutorial-14.png'

import queriesnrqltutorial15 from 'images/queries-nrql_screenshot-crop-tutorial-15.png'

import queriesnrqltutorial16 from 'images/queries-nrql_screenshot-crop-tutorial-16.png'

import queriesnrqltutorial17 from 'images/queries-nrql_screenshot-crop-tutorial-17.png'

import queriesnrqltutorial18 from 'images/queries-nrql_screenshot-crop-tutorial-18.png'

import queriesnrqltutorial19 from 'images/queries-nrql_screenshot-crop-tutorial-19.png'

import queriesnrqltutorial20 from 'images/queries-nrql_screenshot-crop-tutorial-20.png'

We've covered the basics of NRQL in our other topics, such as what NRQL is, how NRQL works, and how NRQL relates to charts and dashboards. With this information, beginning to work with NRQL is the next step, and this tutorial is designed to help you do just that! Below we'll cover some foundational concepts within the language and get you set up with creating a some basic NRQL queries using your data. This tutorial teaches you how to:

* Use `SELECT` and `FROM`
* Use `LIMIT`
* Specify attributes
* Aggregate using average(), max(), min(), sum(), and count()
* Use SINCE and UNTIL
* Plot line graphs with TIMESERIES
* Filter using WHERE
* Group attributes using FACET

Want to learn NRQL within the New Relic platform? We've included a NRQL Lessons application on our [opensource.newrelic.com](https://opensource.newrelic.com/projects/newrelic/nr1-learn-nrql) site to help you quickly see NRQL's value and power within the application. To learn how to install and use the NRQL Lessons app, watch this short YouTube video (approx. 2:45 minutes).

<Video
  id="3UHEHbprs6I"
  type="youtube"
/>

Ready to get started? Let's go!

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="first-query"
    title="1. Your First Query"
  >
  <SideBySide>
  <Side>
Let's start by looking at a single event type in NRDB called **Transaction**, gathered by New Relic APM. Every NRQL query must have `SELECT` and `FROM` clauses: you must `SELECT` some data and tell us where it is `FROM`. Start with this simple query that selects everything from the **Transaction** event type.
 
    ```sql
    SELECT *
    FROM Transaction
    ```

  </Side>
  <Side>
    <img
  title="Select and From example"
  alt="A screenshot of a query with Select and From"
  src={queriesnrqltutorial1}
/>
  </Side>
  </SideBySide>
  <SideBySide>
  <Side>
 This returns a lot of results. Each has a timestamp and a collection of attributes. For now, we only want a single result, so you can limit results to a single record using `LIMIT 1`.

 <Callout variant="important"> When a LIMIT is not supplied the default will be used, which is 100 table rows for SELECT * queries or 10 aggregated values for FACET queries and SELECT (attributes) queries. You can specify any limit up to the maximum. Use LIMIT MAX to return the maximum number of results possible.
</Callout>

    ```sql
    SELECT *
    FROM Transaction
    LIMIT 1
    ```
  </Side>
  <Side>
 <img
  title="Select, From, and Limit"
  alt="A screenshot of a query with Select, From, and Limit"
  src={queriesnrqltutorial2}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    We're now controlling the volume of results we get. But what if we don't want all the attributes? What if we would prefer to see only specific data points? Fortunately, like SQL, this can be done in only a few characters. We replace * with the name of the attribute(s) we want. In this case, we will ask for the name of a transaction and the duration of time it took.

    ```sql
    SELECT name, duration
    FROM Transaction
    ```
    
  </Side>
  <Side>
  <img
  title="Select and From with Duration"
  alt="A screenshot of a query with Select and From using Duration"
  src={queriesnrqltutorial3}
/>
  </Side>
</SideBySide>
With this, you've completed queries that can return either all or some specific attributes of an event, as well as querying a specific number of events. Let's go to the next step!
  </Collapser>
  <Collapser
    className="freq-link"
    id="aggregate-data"
    title="2. Aggregate Data"
  >
<SideBySide>
  <Side>
Instead of viewing individual events, you usually want to view summarized aggregate data across many events. This is where NRDB shines. NRDB can scan billions of events and provide instant, realtime answers to questions about your data.

For example, each `Transaction` event has a duration attribute. This attribute represents how many seconds the call took to execute. Let's see if we can discover the average duration across all `Transaction` events:
```sql
SELECT average(duration) 
FROM Transaction
```
  </Side>
  <Side>
    <img
  title="title1"
  alt="titlealt"
  src={queriesnrqltutorial4}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
NRQL has many built-in functions you can use to aggregate event data. Common functions you might use include `max()`, `min()`, `median()`, and `percentile()`.

In the following example, we ask NRDB for the duration of the slowest transaction from the last 60 minutes.

To do this, we will ask NRDB for the `max(duration).`
```sql
SELECT max(duration) 
FROM Transaction
```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial5}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
We now know how long the slowest customer experience in the last 60 minutes took. Next, let's invert the logic: How long was the fastest experience? If we ask NRDB for `min(duration)` we can find out.
```sql
SELECT min(duration) 
FROM Transaction
```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial6}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
As you can see, `max()` and `min()` both return interesting data points. However, we may also want to perform arithmetic on our data. With sum() we can do basic addition on a numeric attribute. In this query, we will use a new attribute, `databaseCallCount`. This attribute counts the number of database calls each transaction makes. By summing them we can get the total volume of database calls in the default 60 minute time window. (This will be 0 if your apps don't talk to a database.)
```sql
SELECT sum(databaseCallCount) 
FROM Transaction
```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial7}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
Finally, you can also count all recorded Transaction events. We do this with `count(*)`. In this example, we count all recorded events for all applications reporting to New Relic APM:
```sql
SELECT count(*) 
FROM Transaction
```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial8}
/>
  </Side>
</SideBySide>
Now we're doing some really interesting things. We're measuring the boundaries of our performance, grouping event data together, and even calculating information about our chosen attribute. We've chosen duration and calculated the `average`, `max`, and `min`. We learned how to sum up numeric attributes and count all the events for a time period. Manipulating data like this will help us when we want to present data in visualizations, which can assist us in spotting performance issues. Let's go to the next step!
  </Collapser>
  <Collapser
    className="freq-link"
    id="time-ranges"
    title="3. Use Time Ranges"
  >
<SideBySide>
  <Side>
    Every piece of data in NRDB has a `timestamp`. And every query operates on a subset of data within a time range. If you don't provide a time range in your NRQL query, it will return the last 60 minutes by default. We saw this in the previous lesson. But what if we want to see data from a different time range? How do we control the window of data we see? Fortunately, it's very straightforward. Use `SINCE` and `UNTIL` keywords to provide a beginning and end to your query's time range.
```sql 
SELECT average(duration) 
FROM Transaction 
SINCE 1 day ago
```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial9}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    It's also easy to specify time ranges relative to now. You can do this with keywords like `day`, `week`, `hour`, `minute`, or their plural equivalents. There are also logical expressions like `SINCE` today or `SINCE` this week.
```sql
SELECT average(duration) 
FROM Transaction 
SINCE this week
```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial10}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    Here are some sample queries that demonstrate relative time ranges. Note that when specifying a relative time, you need to include the keyword `ago`.
```sql
SELECT average(duration) 
FROM Transaction 
SINCE 1 week ago 
UNTIL 2 days ago
```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial11}
/>
  </Side>
</SideBySide>
We're getting further control of our data now. Adding a time frame to a query lets us define exactly which window of data we want to see.

These controls let us zero in on the data of interest by defining where the data should start and end. In our examples, we saw that we can easily choose the window and use common terms like `week`, `day`, `hour`, `minute`, and their plurals. You can even use `month` and `year` if you're storing that much data in New Relic.
  </Collapser>
  <Collapser
    className="freq-link"
    id="time-series"
    title="4. Query time series"
  >
<SideBySide>
  <Side>
    A common NRQL use case is querying how a value changes over time. This type of query provides data for line charts, area charts, and other visualizations.

"Timeseries" queries in NRDB are a piece of cake. We've already run some to explore aggregation functions `average()`, `max()`, `min()`, `sum()`, and `count()`.

We can take any query made with aggregation functions and add the `TIMESERIES` keyword to plot the values over time.
```sql
SELECT average(duration) 
FROM Transaction 
SINCE 1 day ago 
TIMESERIES
```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial12}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    A time series query breaks the data into a number of buckets over the specified time period. You can have NRDB pick a good default value for the width of that bucket, or you can specify your own. Let's ask NRDB to show us the average duration of application transactions, with returned data organized into 1-hour buckets.
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    SINCE 1 day ago 
    TIMESERIES 1 hour
    ```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial13}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    Notice this returns a flatter graph, since we only have 24 data points across the 1-day period being plotted. But what if you want to see the maximum possible granularity? Well, any timeseries query can have up to 366 data buckets. This means the maximum possible for 24 hours is to bucket our data into 4 minute windows. We could calculate it out and use `TIMESERIES 4 minutes`, or we could ask NRDB to calculate this for us using `TIMESERIES MAX`:
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    SINCE 1 day ago 
    TIMESERIES MAX
    ```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial14}
/>
  </Side>
</SideBySide>
We're moving into new worlds of visualization, breaking out from summarized numbers to line charts of data trends over time. As you can see, using `TIMESERIES` offers full control over visualizations, granularity and averaging data over specified windows.
  </Collapser>
  <Collapser
    className="freq-link"
    id="where"
    title="5. Use Where clauses"
  >
<SideBySide>
  <Side>
    You'll often want your query to operate on a subset of NRDB data. For example, let's query for our backend application's average response time. This data includes an attribute called `transactionType`, which specifies whether the transaction we timed was a "Web", or "Non-Web" (such as a cron job or queued task) transaction. Let's filter our query to only return data for the "Web" transactionType:
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    WHERE transactionType='Web' 
    TIMESERIES
    ```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial15}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    You can also combine `AND` and `OR` to make more complex queries. Use parentheses "(" and ")" to control how these work together.This query shows the average response time of "Web" transactions that were both faster than 100ms, and had a response code of either 200 or 302. Notice how we use parentheses to control the `OR`, which may behave differently than you'd expect.
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    WHERE transactionType='Web' 
    AND duration < 0.1 
    AND (httpResponseCode=200 
    OR httpResponseCode=302) 
    TIMESERIES
    ```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial16}
/>
  </Side>
</SideBySide>
So far, every query we've made has performed actions on all available data in the given time window. But filtering out undesired data is also important. The examples above are useful when we want to filter to a type of transaction, or when a response code is a specific value. Similarly, you could filter to a specific `appName`, Transaction `name` or even a custom attribute you've tagged on your data.
  </Collapser>
  <Collapser
    className="freq-link"
    id="facet"
    title="6. Use faceted queries"
  >
<SideBySide>
  <Side>
    Often, you'll want to determine the "Top N" values grouped by a specific attribute. In NRQL, you do this using `FACET`. For example, here are the slowest `Transaction` calls observed on average, grouped by name. We could describe this as "faceted by name".
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    FACET name 
    SINCE 1 day ago
    ```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial17}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    By default, a faceted query will return the top 10 results; but you can customize how many results are returned with a `LIMIT`. In this example, we will retrieve the top 5 results displayed on a line chart with `TIMESERIES`.
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    FACET name 
    SINCE 3 hours ago 
    LIMIT 5 
    TIMESERIES
    ```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial18}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
    But maybe you don't want a line chart. Perhaps you'd prefer a list of the 20 slowest Transactions. By removing the `TIMESERIES`, we can instead render a bar or pie chart.
    ```sql
    SELECT average(duration) 
    FROM Transaction 
    FACET name 
    SINCE 3 hours ago 
    LIMIT 20
    ```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial19}
/>
  </Side>
</SideBySide>
<SideBySide>
  <Side>
  This query compares the quantity of Web transactions, broken down by individual applications that report to New Relic:
  ```sql
  SELECT count(*) 
  FROM Transaction 
  WHERE transactionType='Web' 
  FACET appName 
  LIMIT 5 
  SINCE 6 hours ago 
  TIMESERIES
  ```
  </Side>
  <Side>
    <img
  title=""
  alt=""
  src={queriesnrqltutorial20}
/>
  </Side>
</SideBySide>
Grouping or "faceting" is important. It allows us to get dimensional with our data. Using the `FACET` keyword is the simplest way to do this. When applying an aggregation function, we can use `FACET` to group by an attribute. You can use any attribute, default or custom, that reports to event data (just like the `WHERE` clause). We recommend tagging on custom data to your events. This allows you to more easily slice and dice the resulting data set.
  </Collapser>
</CollapserGroup>

Congratulations on completing the first NRQL tutorial! If you've made it this far, you now know the basics of querying event data using NRQL. You can create dashboards and alerts and, if you know some React, you can even create your own Apps to run natively inside New Relic One.